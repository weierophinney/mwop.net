<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title type="text">Tag: apigility :: phly, boy, phly</title>
  <updated>2014-09-02T13:30:00+0000</updated>
  <generator uri="http://framework.zend.com" version="2">Zend_Feed_Writer</generator>
  <link rel="alternate" type="text/html" href="http://mwop.net/blog/tag/apigility.html"/>
  <link rel="self" type="application/atom+xml" href="http://mwop.net/blog/tag/apigility-atom.xml"/>
  <id>http://mwop.net/blog/tag/apigility.html</id>
  <entry xmlns:xhtml="http://www.w3.org/1999/xhtml">
    <title type="html"><![CDATA[Deployment with Zend Server (Part 3 of 8)]]></title>
    <published>2014-09-02T13:30:00+0000</published>
    <updated>2014-09-02T13:30:00+0000</updated>
    <link rel="alternate" type="text/html" href="http://mwop.net/blog/2014-09-02-zend-server-deployment-part-3.html"/>
    <id>http://mwop.net/blog/2014-09-02-zend-server-deployment-part-3.html</id>
    <author>
      <name>Matthew Weier O'Phinney</name>
      <email>me@mwop.net</email>
      <uri>http://mwop.net</uri>
    </author>
    <content xmlns:xhtml="http://www.w3.org/1999/xhtml" type="xhtml">
      <xhtml:div xmlns:xhtml="http://www.w3.org/1999/xhtml"><xhtml:p>This is the third in a series of eight posts detailing tips on
deploying to Zend Server. <xhtml:a href="/blog/2014-08-28-zend-server-deployment-part-2.html">The previous
post in the series</xhtml:a> detailed creating recurring jobs via Zend
Job Queue, à la cronjobs.</xhtml:p>
<xhtml:p>Today, I'm sharing a very short deployment script tip learned by
experience.</xhtml:p>
<xhtml:h2>Tip 3: chmod</xhtml:h2>
<xhtml:p>In the <xhtml:a href="/blog/2014-08-11-zend-server-deployment-part-1.html">first
tip</xhtml:a>, I detailed writing deployment scripts. One of the snippets
I shared was a <xhtml:kbd>chmod</xhtml:kbd> routine:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="php">
$command = 'chmod -R a+rwX ./data';
echo "\nExecuting `$command`\n";
system($command);
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>The code is fine; what I did not share is <xhtml:em>where</xhtml:em> in the
deployment script you should invoke it. As I discovered from
experience, this is key.</xhtml:p>
<xhtml:p>Zend Server's deployment scripts run as the <xhtml:kbd>zend</xhtml:kbd>
user. If they are writing any data to the <xhtml:kbd>data</xhtml:kbd>
directory, that data is owned by the <xhtml:kbd>zend</xhtml:kbd> user and group
-- and often will not be writable by the web server user. If you
have scheduled jobs that need to write to the same files, they will
fail... unless you have done the <xhtml:kbd>chmod</xhtml:kbd> after your
deployment tasks are done.</xhtml:p>
<xhtml:p>So, that's today's tip: if you need any directory in your
application to be writable by scheduled jobs, which will run as the
web server user, make sure you do your <xhtml:kbd>chmod</xhtml:kbd> as the last
step of your deployment script.</xhtml:p>
<xhtml:h2>Next time...</xhtml:h2>
<xhtml:p>The next tip in the series is another short one, and will detail
how to secure your Job Queue job scripts.</xhtml:p>
<xhtml:h2>Other articles in the series</xhtml:h2>
<xhtml:ul>
<xhtml:li><xhtml:a href="/blog/2014-08-11-zend-server-deployment-part-1.html">Tip 1:
zf-deploy</xhtml:a></xhtml:li>
<xhtml:li><xhtml:a href="/blog/2014-08-28-zend-server-deployment-part-2.html">Tip 2:
Recurring Jobs</xhtml:a></xhtml:li>
</xhtml:ul>
I will update this post to link to each article as it releases.</xhtml:div>
    </content>
  </entry>
  <entry xmlns:xhtml="http://www.w3.org/1999/xhtml">
    <title type="html"><![CDATA[Deployment with Zend Server (Part 2 of 8)]]></title>
    <published>2014-08-28T13:30:00+0000</published>
    <updated>2014-09-02T13:30:00+0000</updated>
    <link rel="alternate" type="text/html" href="http://mwop.net/blog/2014-08-28-zend-server-deployment-part-2.html"/>
    <id>http://mwop.net/blog/2014-08-28-zend-server-deployment-part-2.html</id>
    <author>
      <name>Matthew Weier O'Phinney</name>
      <email>me@mwop.net</email>
      <uri>http://mwop.net</uri>
    </author>
    <content xmlns:xhtml="http://www.w3.org/1999/xhtml" type="xhtml">
      <xhtml:div xmlns:xhtml="http://www.w3.org/1999/xhtml"><xhtml:p>This is the second in a series of eight posts detailing tips on
deploying to Zend Server. <xhtml:a href="/blog/2014-08-11-zend-server-deployment-part-1.html">The previous
post in the series</xhtml:a> detailed getting started with <xhtml:a href="http://www.zend.com/en/solutions/cloud-solutions/aws-marketplace">Zend
Server on the AWS marketplace</xhtml:a> and using <xhtml:a href="https://github.com/zfcampus/zf-deploy">zf-deploy</xhtml:a> to create ZPK
packages to deploy to Zend Server.</xhtml:p>
<xhtml:p>Today, I'm looking at how to created scheduled/recurring jobs
using Zend Server's Job Queue; think of this as application-level
cronjobs.</xhtml:p>
<xhtml:h2>Tip 2: Recurring Jobs</xhtml:h2>
<xhtml:p>I needed to define a few recurring jobs on the server. In the
past, I've used <xhtml:kbd>cron</xhtml:kbd> for this, but I've recently had a
slight change of mind on this: if I use <xhtml:kbd>cron</xhtml:kbd>, I have to
assume I'm running on a unix-like system, and have some sort of
system access to the server. If I have multiple servers running,
that means ensuring they're setup on each server. It seems better
to be able to define these jobs at the applicaton level.</xhtml:p>
<xhtml:p>Since Zend Server comes with Job Queue, I decided to try it out
for scheduling recurring jobs. This is not terribly intuitive,
however. The UI allows you to define scheduled jobs... but only
gives options for every minute, hour, day, week, and month, without
allowing you to specify the exact interval (e.g., every day at
20:00).</xhtml:p>
<xhtml:p>The PHP API, however, makes this easy. I can create a job as
follows:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="php">
$queue = new ZendJobQueue();
$queue-&gt;createHttpJob('/jobs/github-feed.php', [], [
  'name'       =&gt; 'github-feed',
  'persistent' =&gt; false,
  'schedule'   =&gt; '5,20,35,40 * * * *',
]);
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>Essentially, you provide a URL to the script to execute (Job
Queue "runs" a job by accessing a URL on the server), and provide a
schedule in crontab format. I like to give my jobs names as well,
as it allows me to search for them in the UI, and also enables
linking between the rules and the logs in the UI. Marking them as
<xhtml:em>not</xhtml:em> persistent ensures that if the job is successful, it
will be removed from the events list.</xhtml:p>
<xhtml:p>The question is, where do you define this? I decided to do this
in my <xhtml:kbd>post_activate.php</xhtml:kbd> deployment script. However, this
raises two new problems:</xhtml:p>
<xhtml:ul>
<xhtml:li>Rules need not just a path to the script, but also the scheme
and host. You _can_ omit those, but only if the script can resolve
them via <xhtml:kbd>$_SERVER</xhtml:kbd>... which it cannot due during
deployment.</xhtml:li>
<xhtml:li>Each deployment adds the jobs you define... but this does not
overwrite or remove the jobs you added in previous
deployments.</xhtml:li>
</xhtml:ul>
<xhtml:p>I solved these as follows:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="php">
$server = 'http://mwop.net';

// Remove previously scheduled jobs:
$queue = new ZendJobQueue();
foreach ($queue-&gt;getSchedulingRules() as $job) {
    if (0 !== strpos($job['script'], $server)) {
        // not one we're interested in
        continue;
    }

    // Remove previously scheduled job
    $queue-&gt;deleteSchedulingRule($job['id']);
}

$queue-&gt;createHttpJob($server . '/jobs/github-feed.php', [], [
  'name'       =&gt; 'github-feed',
  'persistent' =&gt; false,
  'schedule'   =&gt; '5,20,35,40 * * * *',
]);
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>So, in summary:</xhtml:p>
<xhtml:ul>
<xhtml:li>Define your rules with names.</xhtml:li>
<xhtml:li>Define recurring rules using the <xhtml:kbd>schedule</xhtml:kbd>
option.</xhtml:li>
<xhtml:li>Define recurring rules in your deployment script, during
<xhtml:kbd>post_activate</xhtml:kbd>.</xhtml:li>
<xhtml:li>Remove previously defined rules in your deployment script,
prior to defining them.</xhtml:li>
</xhtml:ul>
<xhtml:h2>Next time...</xhtml:h2>
<xhtml:p>The next tip in the series is a short one, perfect for following
the US Labor Day weekend, and details something I learned the hard
way from Tip 1 when setting up deployment tasks.</xhtml:p>
<xhtml:h2>Other articles in the series</xhtml:h2>
<xhtml:ul>
<xhtml:li><xhtml:a href="/blog/2014-08-11-zend-server-deployment-part-1.html">Tip 1:
zf-deploy</xhtml:a></xhtml:li>
<xhtml:li><xhtml:a href="/blog/2014-09-02-zend-server-deployment-part-3.html">Tip 3:
chmod</xhtml:a></xhtml:li>
</xhtml:ul>
I will update this post to link to each article as it releases.</xhtml:div>
    </content>
  </entry>
  <entry xmlns:xhtml="http://www.w3.org/1999/xhtml">
    <title type="html"><![CDATA[Deployment with Zend Server (Part 1 of 8)]]></title>
    <published>2014-08-26T20:15:00+0000</published>
    <updated>2014-09-02T13:30:00+0000</updated>
    <link rel="alternate" type="text/html" href="http://mwop.net/blog/2014-08-11-zend-server-deployment-part-1.html"/>
    <id>http://mwop.net/blog/2014-08-11-zend-server-deployment-part-1.html</id>
    <author>
      <name>Matthew Weier O'Phinney</name>
      <email>me@mwop.net</email>
      <uri>http://mwop.net</uri>
    </author>
    <content xmlns:xhtml="http://www.w3.org/1999/xhtml" type="xhtml">
      <xhtml:div xmlns:xhtml="http://www.w3.org/1999/xhtml"><xhtml:p>I manage a number of websites running on Zend Server, Zend's PHP
application platform. I've started accumulating a number of
patterns and tricks that make the deployments more successful, and
which also allow me to do more advanced things such as setting up
recurring jobs for the application, clearing page caches, and
more.</xhtml:p>
<xhtml:h2>Yes, YOU can afford Zend Server</xhtml:h2>
<xhtml:p>"But, wait, Zend Server is uber-expensive!" I hear some folks
saying.</xhtml:p>
<xhtml:p>Well, yes and no.</xhtml:p>
<xhtml:p>With the release of Zend Server 7, Zend now offers a
"Development Edition" that contains all the features I've covered
here, and which runs $195. This makes it affordable for small shops
and freelancers, but potentially out of the reach of
individuals.</xhtml:p>
<xhtml:p>But there's another option, which I'm using, which is even more
intriguing: <xhtml:a href="http://www.zend.com/en/solutions/cloud-solutions/aws-marketplace">Zend
Server on the Amazon Web Services (AWS) Marketplace</xhtml:a>. On AWS,
you can try out Zend Server free for 30 days. After that, you get
charged a fee on top of your normal AWS EC2 usage. Depending on the
EC2 instance you choose, this can run as low as ~$24/month (this is
on the t1.micro, and that's the total per month for both AWS and
Zend Server usage). That's cheaper than most VPS hosting or PaaS
providers, and gives you a full license for Zend Server.</xhtml:p>
<xhtml:p>Considering Zend Server is available on almost every PaaS and
IaaS offering available, this is a great way to try it out, as well
as to setup staging and testing servers cheaply; you can then
choose the provider you want based on its other features. For those
of you running low traffic or small, personal or hobbyist sites,
it's an inexpensive alternative to VPS hosting.</xhtml:p>
<xhtml:p>So... onwards with my first tip.</xhtml:p>
<xhtml:h2>Tip 1: zf-deploy</xhtml:h2>
<xhtml:p>My first trick is to use <xhtml:a href="https://github.com/zfcampus/zf-deploy">zf-deploy</xhtml:a>. This is a
tool <xhtml:a href="https://twitter.com/ezimuel">Enrico</xhtml:a> and I wrote
when prepping <xhtml:a href="https://apigility.org">Apigility</xhtml:a> for its
initial stable release. It allows you to create deployment packages
from your application, including zip, tarball, and ZPKs (Zend
Server deployment packages). We designed it to simplify packaging
<xhtml:a href="http://framework.zend.com">Zend Framework 2</xhtml:a> and
Apigility applications, but with a small amount of work, it could
likely be used for a greater variety of PHP applications.</xhtml:p>
<xhtml:p>zf-deploy takes the current state of your working directory, and
clones it to a working path. It then runs Composer (though you can
disable this), and strips out anything configured in your
<xhtml:kbd>.gitignore</xhtml:kbd> file (again, you can disable this). From
there, it creates your package.</xhtml:p>
<xhtml:p>One optional piece is that, when creating a ZPK, you can tell it
which <xhtml:kbd>deployment.xml</xhtml:kbd> you want to use and/or specify a
directory containing the <xhtml:kbd>deployment.xml</xhtml:kbd> and any install
scripts you want to include in the package. This latter is
incredibly useful, as you can use this to shape your
deployment.</xhtml:p>
<xhtml:p>As an example, on my own website, I have a CLI job that will
fetch my latest <xhtml:a href="https://github.com">GitHub</xhtml:a> activity. I
can invoke that in my <xhtml:kbd>post_stage.php</xhtml:kbd> script:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="php">
if (! chdir(getenv('ZS_APPLICATION_BASE_DIR'))) {
  throw new Exception('Unable to change to application directory');
}

$php = '/usr/local/zend/bin/php';

$command = $php . ' public/index.php githubfeed fetch';
echo "\nExecuting `$command`\n";
system($command);
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>One task I always do is make sure my application data directory
is writable by the web server. This next line builds on the above,
in that it assumes you've changed to your application directory
first:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="php">
$command = 'chmod -R a+rwX ./data';
echo "\nExecuting `$command`\n";
system($command);
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>Yes, PHP has a built-in for <xhtml:kbd>chmod</xhtml:kbd>, but it doesn't act
recursively.</xhtml:p>
<xhtml:p>For ZF2 and Apigility applications, zf-deploy also allows you to
specify a directory that contains the <xhtml:kbd>*local.php</xhtml:kbd> config
scripts for your <xhtml:kbd>config/autoload/</xhtml:kbd> directory, allowing
you to merge in configuration specific for the deployment
environment. This is a fantastic capability, as I can keep any
private configuration separate from my main repository.</xhtml:p>
<xhtml:p>Deployment now becomes:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="bash">
$ vendor/bin/zfdeploy.php mwop.net.zpk --configs=../mwop.net-config --zpk=zpk
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>and I now have a ZPK ready to push to Zend Server.</xhtml:p>
<xhtml:p>In sum: zf-deploy simplifies ZPK creation, and allows you to add
deployment scripts that let you perform other tasks on the
server.</xhtml:p>
<xhtml:h2>Next time...</xhtml:h2>
<xhtml:p>I've got a total of 8 tips queued up, including this one, and
will be publishing on Tuesdays and Thursdays; I'll update each post
to link to the others in the series. Next tip: creating scheduled
Job Queue jobs, à la cronjobs.</xhtml:p>
<xhtml:h2>Other articles in the series</xhtml:h2>
<xhtml:ul>
<xhtml:li><xhtml:a href="/blog/2014-08-28-zend-server-deployment-part-2.html">Tip 2:
Recurring Jobs</xhtml:a></xhtml:li>
<xhtml:li><xhtml:a href="/blog/2014-09-02-zend-server-deployment-part-3.html">Tip 3:
chmod</xhtml:a></xhtml:li>
</xhtml:ul>
I will update this post to link to each article as it releases.</xhtml:div>
    </content>
  </entry>
  <entry xmlns:xhtml="http://www.w3.org/1999/xhtml">
    <title type="html"><![CDATA[Apigility: Using RPC with HAL]]></title>
    <published>2014-03-26T20:30:00+0000</published>
    <updated>2014-03-26T20:30:00+0000</updated>
    <link rel="alternate" type="text/html" href="http://mwop.net/blog/2014-03-26-apigility-rpc-with-hal.html"/>
    <id>http://mwop.net/blog/2014-03-26-apigility-rpc-with-hal.html</id>
    <author>
      <name>Matthew Weier O'Phinney</name>
      <email>me@mwop.net</email>
      <uri>http://mwop.net</uri>
    </author>
    <content xmlns:xhtml="http://www.w3.org/1999/xhtml" type="xhtml">
      <xhtml:div xmlns:xhtml="http://www.w3.org/1999/xhtml"><xhtml:p>A few days ago, we <xhtml:a href="http://bit.ly/ag-1-beta1">released
our first beta of Apigility</xhtml:a>. We've started our documentation
effort now, and one question has arisen a few times that I want to
address: How can you use Hypermedia Application Language (HAL) in
RPC services?</xhtml:p>
<xhtml:h2>HAL?</xhtml:h2>
<xhtml:p><xhtml:a href="http://tools.ietf.org/html/draft-kelly-json-hal-06">Hypermedia
Application Language</xhtml:a> is an IETF proposal for how to represent
resources and their relations within APIs. Technically, it provides
two mediatypes, <xhtml:code>application/hal+json</xhtml:code> and
<xhtml:code>application/hal+xml</xhtml:code>; however, Apigility only provides
the JSON variant.</xhtml:p>
<xhtml:p>The important things to know about HAL are:</xhtml:p>
<xhtml:ul>
<xhtml:li>
<xhtml:p>It provides a standard way of describing relational links. All
relational links are under a <xhtml:code>_links</xhtml:code> property of the
resource. That property is an object. Each property of that object
is a link relation; the value of each link relation is an object
(or array of such objects) describing the link that must minimally
contain an <xhtml:code>href</xhtml:code> proerty. The link object itself can
contain some additional metadata, such as a mediatype, a name
(useful for differentiating between multiple link objects assigned
to the same relation).</xhtml:p>
<xhtml:p>While not required, the specification recommends resources
contain a "self" relational link, indicating the canonical location
for the resource. This is particularly useful when we consider
embedding (the next topic).</xhtml:p>
<xhtml:p>Sound hard? It's not:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="javascript">
{
    "_links": {
        "self": {
            "href": "/blog/2014-03-26-apigility-rpc-with-hal"
        }
    }
}
        </xhtml:code>
</xhtml:pre></xhtml:div>
</xhtml:li>
<xhtml:li>
<xhtml:p>Besides link relations, HAL also provides a standard way of
describing <xhtml:em>embedded resources</xhtml:em>. An embedded resource is any
other resource you can address via your API, and, as such, would be
structured as a HAL resource -- in other words, it would have a
<xhtml:code>_links</xhtml:code> property with relational links. Essentially,
any property of the resource you're returning that can itself be
addressed via the URI must be <xhtml:em>embedded</xhtml:em> in the resource.
This is done via the property <xhtml:code>_embedded</xhtml:code>.</xhtml:p>
<xhtml:p>Like <xhtml:code>_links</xhtml:code>, <xhtml:code>_embedded</xhtml:code> is an object.
Each key in the object is the local name by which the resource
refers to the embedded resource. The value of such keys can either
be HAL resources or <xhtml:em>arrays</xhtml:em> of HAL resources; in fact, this
is how <xhtml:em>collections</xhtml:em> are represented in HAL!</xhtml:p>
<xhtml:p>As examples:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="javascript">
{
    "_links": {
        "self": {
            "href": "/blog/2014-03-26-apigility-rpc-with-hal"
        }
    },
    "_embedded": {
        "author": {
            "_links": {
                "self": {
                    "href": "/blog/author/matthew"
                }
            },
            "id": "matthew",
            "name": "Matthew Weier O'Phinney",
            "url": "http://mwop.net"
        },
        "tags": [
            {
                "_links": {
                    "self": {
                        "href": "/blog/tag/php"
                    }
                },
                "id": "php"
            },
            {
                "_links": {
                    "self": {
                        "href": "/blog/tag/rest"
                    }
                },
                "id": "rest"
            }
        ]
    }
}
        </xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>The example above shows two embedded resources. The first is the
author; the second, a collection of tags. Note that <xhtml:em>every</xhtml:em>
object under <xhtml:code>_embedded</xhtml:code> is a HAL object!</xhtml:p>
<xhtml:p>You can go quite far with this -- you can also have embedded
resources inside your embedded resources, arbitrarily deep.</xhtml:p>
</xhtml:li>
</xhtml:ul>
<xhtml:h2>RPC?</xhtml:h2>
<xhtml:p>RPC stands for Remote Procedure Call, and, when describing a web
API, is usually used to describe a web service that publishes
multiple method calls at a single URI using only <xhtml:code>POST</xhtml:code>;
XML-RPC and SOAP are the usual suspects.</xhtml:p>
<xhtml:p>In Apigility, we use the term RPC in a much looser sense; we use
it to describe one-off services: actions like "authenticate," or
"notify," or "register" would all make sense here. They are actions
that usually only need to respond to a single HTTP method, and
which may or may not describe a "thing", which is what we usually
consider a "resource" when discussing REST terminology.</xhtml:p>
<xhtml:p>That said: what if what we want to return from the RPC call
<xhtml:em>are</xhtml:em> REST resources?</xhtml:p>
<xhtml:h2>Returning HAL from RPC Services</xhtml:h2>
<xhtml:p>In order to return HAL from RPC services, we need to understand
(a) how Content Negotiation works, and (b) what needs to be
returned in order for the HAL renderer to be able to create a
representation.</xhtml:p>
<xhtml:p>For purposes of this example, I'm positing a
<xhtml:code>RegisterController</xhtml:code> as an RPC service that, on success,
is returning a <xhtml:code>User</xhtml:code> object that I want rendered as a
HAL resource.</xhtml:p>
<xhtml:p>The <xhtml:a href="https://github.com/zfcampus/zf-content-negotiation">zf-content-negotiation</xhtml:a>
module takes care of content negotiation for Apigility. It
introspects the <xhtml:code>Accept</xhtml:code> header in order to determine if
we can return a representation, and then, if it can, will cast any
<xhtml:code>ZF\ContentNegotiation\ViewModel</xhtml:code> returned from a
controller to the appropriate view model for the representation.
From there, a renderer will pick up the view model and do what
needs to be done.</xhtml:p>
<xhtml:p>So, the first thing we have to do is return
<xhtml:code>ZF\ContentNegotiation\ViewModel</xhtml:code> instances from our
controller.</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="php">
use Zend\Mvc\Controller\AbstractActionController;
use ZF\ContentNegotiation\ViewModel;

class RegisterController extends AbstractActionController
{
    public function registerAction()
    {
        /* ... do some work ... get a user ... */
        return new ViewModel(array('user' =&gt; $user));
    }
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>The <xhtml:a href="https://github.com/zfcampus/zf-hal">zf-hal</xhtml:a>
module in Apigility creates the actual HAL representations.
<xhtml:code>zf-hal</xhtml:code> looks for a "payload" variable in the view
model, and expects that value to be either a
<xhtml:code>ZF\Hal\Entity</xhtml:code> (single item) or
<xhtml:code>ZF\Hal\Collection</xhtml:code>. When creating an
<xhtml:code>Entity</xhtml:code> object, you need the object being represented,
as well as the identifier. So, let's update our return value.</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="php">
use Zend\Mvc\Controller\AbstractActionController;
use ZF\ContentNegotiation\ViewModel;
use ZF\Hal\Entity;

class RegisterController extends AbstractActionController
{
    public function registerAction()
    {
        /* ... do some work
         * ... get a $user
         * ... assume we have also now have an $id
         */
        return new ViewModel(array('payload' =&gt; array(
            'user' =&gt; new Entity($user, $id),
        )));
    }
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p><xhtml:code>zf-hal</xhtml:code> contains what's called a "metadata map".
This is a map of classes to information on how <xhtml:code>zf-hal</xhtml:code>
should render them: what route to use, what additional relational
links to inject, how to serialize the object, what field represents
the identifier, etc.</xhtml:p>
<xhtml:p>In most cases, you will have likely already defined a REST
service for the resource you want to return from the RPC service,
in which case you will be done. However, if you want, you can go in
and manually configure the metadata map in your API module's
<xhtml:code>config/module.config.php</xhtml:code> file:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="php">
return array(
    /* ... */
    'zf-hal' =&gt; array(
        'metadata_map' =&gt; array(
            'User' =&gt; array(
                'route_name' =&gt; 'api.rest.user',
                'entity_identifier_name' =&gt; 'username',
                'route_identifier_name' =&gt; 'user_id',
                'hydrator' =&gt; 'Zend\Stdlib\Hydrator\ObjectProperty',
            ),
        ),
    ),
);
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>Finally, we need to make sure that the service is configured to
actually return HAL. We can do this in the admin if we want. Find
the "Content Negotiation" section of the admin, and the "Content
Negotiation Selector" item, and set that to "HalJson"; don't forget
to save! Alternately, you can do this manually in the API module's
<xhtml:code>config/module.config.php</xhtml:code> file, under the
<xhtml:code>zf-content-negotiation</xhtml:code> section:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="php">
return array(
    /* ... */
    'zf-content-negotiation' =&gt; array(
        'controllers' =&gt; array(
            /* ... */
            'RegisterController' =&gt; 'HalJson',
        ),
        /* ... */
    ),
);
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>Once your changes are complete, when you make a successful
request to the URI for your "register" RPC service, you'll receive
a HAL response pointing to the canonical URI for the user resource
created!</xhtml:p>
</xhtml:div>
    </content>
  </entry>
</feed>
