<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title type="text">Tag: oop :: phly, boy, phly</title>
  <updated>2012-12-20T20:23:00+0000</updated>
  <generator uri="http://framework.zend.com" version="2.0.5">Zend_Feed_Writer</generator>
  <link rel="alternate" type="text/html" href="http://mwop.net/blog/tag/oop.html"/>
  <link rel="self" type="application/atom+xml" href="http://mwop.net/blog/tag/oop-atom.xml"/>
  <id>http://mwop.net/blog/tag/oop.html</id>
  <entry xmlns:xhtml="http://www.w3.org/1999/xhtml">
    <title type="html"><![CDATA[On php-fig and Shared Interfaces]]></title>
    <published>2012-12-20T20:23:00+0000</published>
    <updated>2012-12-20T20:23:00+0000</updated>
    <link rel="alternate" type="text/html" href="http://mwop.net/blog/2012-12-20-on-shared-interfaces.html"/>
    <id>http://mwop.net/blog/2012-12-20-on-shared-interfaces.html</id>
    <author>
      <name>Matthew Weier O'Phinney</name>
      <email>me@mwop.net</email>
      <uri>http://mwop.net</uri>
    </author>
    <content xmlns:xhtml="http://www.w3.org/1999/xhtml" type="xhtml">
      <xhtml:div xmlns:xhtml="http://www.w3.org/1999/xhtml"><xhtml:p>This is a post I've been meaning to write for a long time, and
one requested of me personally by <xhtml:a href="http://www.rooftopsolutions.nl/blog/">Evert Pot</xhtml:a> during the
Dutch PHP Conference in June 2012. It details some observations I
have of php-fig, and hopefully will serve as a record of why I'm
not directly participating any longer.</xhtml:p>
<xhtml:p>I was a founding member of the <xhtml:a href="http://www.php-fig.org/">Framework Interoperability Group</xhtml:a>, now
called "php-fig". I was one of around a dozen folks who sat around
a table in 2009 in Chicago during php|tek and started discussions
about what we could all do to make it possible to work better
together between our projects, and make it simpler for users to
pick and choose from our projects in order to build the solutions
to their own problems.</xhtml:p>
<xhtml:p>The first "standard" that came from this was <xhtml:a href="https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-0.md">
PSR-0</xhtml:a>, which promoted a standard class naming convention that
uses a 1:1 relationship between the namespace and/or vendor prefix
and the directory hierarchy, and the class name and the filename in
which it lives. To this day, there are both those who hail this as
a great step forward for cooperation, and simultaneously others who
feel it's a terrible practice.</xhtml:p>
<xhtml:p>And then nothing, for years. But a little over a year ago, there
was a new push by a number of folks wanting to do more. Paul Jones
did a remarkable job of spearheading the next <xhtml:a href="https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-1-basic-coding-standard.md">
two</xhtml:a> <xhtml:a href="https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-2-coding-style-guide.md">
standards</xhtml:a>, which centered around coding style. Again, just like
with PSR-0, we had both those feeling it was a huge step forward,
and those who loathe the direction.</xhtml:p>
<xhtml:p>What was interesting, though, was that once we started seeing
some new energy and momentum, it seemed that <xhtml:em>everyone</xhtml:em>
wanted a say. And we started getting dozens of folks a week asking
to be voting members, and new proposal after new proposal. Whether
or not somebody likes an existing standard, they want to have
backing for a standard they propose.</xhtml:p>
<xhtml:p>And this is when we started seeing proposals surface for shared
interfaces, first around caching, and now around logging (though
the latter is the first up for vote).</xhtml:p>
<xhtml:h2>Shared Interfaces</xhtml:h2>
<xhtml:p>The idea around shared interfaces is simple: if we can come to a
consensus on the basic interface for a common application task,
libraries and frameworks can typehint on that shared interface,
allowing developers to drop in the implementation of their choosing
-- or even a standard, reference implementation. The goal is to
prevent Not Invented Here (NIH) syndrome, as well as to make it
simpler to re-use components between one library and another. As an
example, if you're using Framework A, and it has a caching library,
and you're consuming ORM B, you'd be able to pass the same cache
object to the ORM as you use in the framework.</xhtml:p>
<xhtml:p>Great goals, really.</xhtml:p>
<xhtml:p>But I'm not sure I buy into them.</xhtml:p>
<xhtml:h2>Problems</xhtml:h2>
<xhtml:p>First, I agree that NIH is a problem.</xhtml:p>
<xhtml:p>Second, I <xhtml:em>also</xhtml:em> think there's space for <xhtml:em>multiple
implementations</xhtml:em> of any given component. Often there are
different approaches that different authors will take: one might
focus on performance, another on having multiple adapters for
providing different capabilities, etc. Sometimes having a different
background will present different problem areas you want to
resolve. As such, having multiple implementations can be a very
good thing; developers can look at what each provides, and
determine which solves the particular issues presented in the
current project.</xhtml:p>
<xhtml:p>Because of this latter point, I have my reservations about
shared interfaces.</xhtml:p>
<xhtml:p>What if a particular approach requires deviating from the shared
interface in order to accomplish its goals? Additionally, in order
to keep the greatest amount of compatibility between projects,
shared interfaces tend to be so generic that specific
implementations require developers to do a ton of manual type
checking and munging of parameters, leading to more overhead, more
difficulty testing and maintaining, and more difficulty documenting
and understanding.</xhtml:p>
<xhtml:p>As an example, consider the following (made up) signature for a
log method:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="php">
public function log($message, array $context = null);
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>What if your library supports an idea of priorities? Where would
that information go in the above signature -- and would that differ
between libraries -- would one library use the key for a completely
different purpose? What about logging objects -- the signature
doesn't say you can't, but how would I know if a specific
implementation supports it, and won't blow up if I do pass one? Why
must the <xhtml:code>$context</xhtml:code> be an array -- why won't any
<xhtml:code>Traversable</xhtml:code> or <xhtml:code>ArrayAccess</xhtml:code> object
work?</xhtml:p>
<xhtml:p>Basically, by being overly generic, the signature becomes a
liability for those implementing the interface; it prevents
meaningful interoperability and leads to splintering
implementations.</xhtml:p>
<xhtml:p><xhtml:em>(Please note: the above is completely fictional and has no
bearing on current proposed or accepted standards. It is a thought
exercise only.)</xhtml:em></xhtml:p>
<xhtml:p>Furthermore, if a given project writes their own implementation
of a component, and it has specialized features, why would they
want to typehint on a generic, shared interface that doesn't
implement those features? This would be counter-intuitive, as the
project would then need to either check on additional interfaces
for the specialized capabilities, duck-type, etc. -- all of which
make for more maintenance and code.</xhtml:p>
<xhtml:p>In summary, my primary problem with the idea of shared
interfaces is that I feel there is always room for new thinking and
ideas in any given problem space, and that this thinking should not
be restricted by what already exists. Secondarily, I feel that it's
okay for a given project to be selective about what capabilities it
requires for its internal consumption and consistency, and should
not limit itself to a standardized interface.</xhtml:p>
<xhtml:h2>But, but, SHARING</xhtml:h2>
<xhtml:p><xhtml:em>Remember, the first point I made was that I think NIH is a
problem.</xhtml:em> How do I reconcile that with a firm stance against
shared interfaces?</xhtml:p>
<xhtml:p>Easy: <xhtml:a href="http://en.wikipedia.org/wiki/Bridge_pattern">bridges</xhtml:a> and/or
<xhtml:a href="http://en.wikipedia.org/wiki/Adapter_pattern">adapters</xhtml:a>.</xhtml:p>
<xhtml:p>Let's go back to that example of Framework A, its caching
library, and working with ORM B.</xhtml:p>
<xhtml:p>Let's assume that ORM B defines an interface for caching, and
let's say it looks like this:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="php">
interface CacheInterface
{
    public function set($key, $data);
    public function has($key);
    public function get($key);
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>Furthermore, we'll assume that the expected parameter values and
return types are documented.</xhtml:p>
<xhtml:p>What we as a consumer of both Framework A and ORM B can do is
build an <xhtml:em>implementation</xhtml:em> of <xhtml:code>CacheInterface</xhtml:code>
that accepts a cache instance from Framework A, and proxies the
various interface methods to that instance.</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="php">
class FrameworkACache implements CacheInterface
{
    protected $cache;

    public function __construct(Cache $cache)
    {
        $this-&gt;cache = $cache;
    }

    public function set($key, $data)
    {
        $item = new CacheItem($key, $data);
        $this-&gt;cache-&gt;setItem($item);
    }

    public function has($key)
    {
        return $this-&gt;cache-&gt;exists($key);
    }

    public function get($key)
    {
        $item = $this-&gt;cache-&gt;getItem($key);
        return $item-&gt;getData();
    }
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>Assuming your code is well-decoupled, and you're using some sort
of Inversion of Control container, you can likely create a factory
for your ORM that will grab the above class, with the cache
injected, and inject it into the ORM instance. Yes, it's a bit more
work, but it's difficult to question the end result: shared caching
between the framework and the ORM - and no need for shared
interfaces, nor any need to sacrifice features within the framework
or the ORM.</xhtml:p>
<xhtml:h2>Sharing is good, developing solutions is better</xhtml:h2>
<xhtml:p>I think the core idea of the php-fig group is sound: <xhtml:em>let's
all start thinking about how we can make it easier to operate with
each other</xhtml:em>. That said, my thoughts on how to accomplish that
goal have changed significantly, and boil down to:</xhtml:p>
<xhtml:ul>
<xhtml:li>Use naming conventions that will reduce collisions (i.e., use
per-project vendor prefixes/namespaces)</xhtml:li>
<xhtml:li>Use semantic versioning</xhtml:li>
<xhtml:li>Keep your installation packages segregated</xhtml:li>
<xhtml:li>Have a simple, discoverable way to autoload</xhtml:li>
<xhtml:li>Provide interfaces for anything that could benefit from
alternate implementations</xhtml:li>
<xhtml:li>Don't write code that has side-effects in the global namespace
(including altering PHP settings or superglobals)</xhtml:li>
</xhtml:ul>
<xhtml:p>Following these principals, you can play nice with each other,
while still fostering innovative and differentiating solutions to
shared problems.</xhtml:p>
</xhtml:div>
    </content>
  </entry>
  <entry xmlns:xhtml="http://www.w3.org/1999/xhtml">
    <title type="html"><![CDATA[PHP Master Series on Day Camp For Developers]]></title>
    <published>2012-12-18T20:24:00+0000</published>
    <updated>2012-12-18T20:24:00+0000</updated>
    <link rel="alternate" type="text/html" href="http://mwop.net/blog/2012-12-18-php-master-series.html"/>
    <id>http://mwop.net/blog/2012-12-18-php-master-series.html</id>
    <author>
      <name>Matthew Weier O'Phinney</name>
      <email>me@mwop.net</email>
      <uri>http://mwop.net</uri>
    </author>
    <content xmlns:xhtml="http://www.w3.org/1999/xhtml" type="xhtml">
      <xhtml:div xmlns:xhtml="http://www.w3.org/1999/xhtml"><xhtml:p><xhtml:a href="http://blog.calevans.com">Cal Evans</xhtml:a> has organized
another DayCamp4Developers event, this time entitled "<xhtml:a href="http://blog.calevans.com/2012/11/19/php-master-series-vol-1">PHP
Master Series, Volume 1</xhtml:a>". I'm honored to be an invited speaker
for this first edition, where I'll be presenting my talk,
"Designing Beautiful Software".</xhtml:p>
<xhtml:p>Why would you want to participate? Well, for one, because you
can interact directly with the various speakers during the
presentations. Sure, you can likely find the slide decks elsewhere,
or possibly even recordings. But if we all do our jobs right, we'll
likely raise more questions than answers; if you attend, you'll get
a chance to ask some of your questions immediately, <xhtml:em>and we may
even answer them!</xhtml:em></xhtml:p>
<xhtml:p>On top of that, this is a fantastic lineup of speakers, and,
frankly, not a lineup I've ever participated in. In a typical
conference, you'd likely see one or two of us, and be lucky if we
weren't scheduled against each other; if you attend this week,
you'll get to see us all, back-to-back.</xhtml:p>
<xhtml:p>What else will you be doing this Friday, anyways, while <xhtml:a href="http://en.wikipedia.org/wiki/2012_phenomenon">you wait for the end
of the world?</xhtml:a></xhtml:p>
<xhtml:p>So, do yourself a favor, and <xhtml:a href="http://phpmasterseriesv1.eventbrite.com/">register today</xhtml:a>!</xhtml:p>
</xhtml:div>
    </content>
  </entry>
  <entry xmlns:xhtml="http://www.w3.org/1999/xhtml">
    <title type="html"><![CDATA[My ZendCon Beautiful Software Talk]]></title>
    <published>2012-11-17T13:53:00+0000</published>
    <updated>2012-11-17T13:53:00+0000</updated>
    <link rel="alternate" type="text/html" href="http://mwop.net/blog/2012-11-17-zendcon-beautiful-software.html"/>
    <id>http://mwop.net/blog/2012-11-17-zendcon-beautiful-software.html</id>
    <author>
      <name>Matthew Weier O'Phinney</name>
      <email>me@mwop.net</email>
      <uri>http://mwop.net</uri>
    </author>
    <content xmlns:xhtml="http://www.w3.org/1999/xhtml" type="xhtml">
      <xhtml:div xmlns:xhtml="http://www.w3.org/1999/xhtml"><xhtml:p>Once again, I spoke at <xhtml:a href="http://www.zendcon.com/">ZendCon</xhtml:a> this year; in talking with
<xhtml:a href="http://twitter.com/chwenz">Christian Wenz</xhtml:a>, we're
pretty sure that the two of us and <xhtml:a href="http://andigutmans.blogspot.com">Andi</xhtml:a> are the only ones who
have spoken at all eight events.</xhtml:p>
<xhtml:p>Unusually for me, I did not speak on a Zend Framework topic, and
had only one regular slot (I also co-presented a Design Patterns
tutorial with my team). That slot, however, became one of my
favorite talks I've delivered: "Designing Beautiful Software". I've
given this talk a couple times before, but I completely rewrote it
for this conference in order to better convey my core message:
beautiful software is maintainable and extensible; writing software
is a craft.</xhtml:p>
<xhtml:p>I discovered today that not only was it recorded, but it's been
<xhtml:a href="http://youtu.be/mQsQ6QZ4dGg">posted on YouTube</xhtml:a>:</xhtml:p>
<xhtml:iframe width="420" height="315" src="http://www.youtube.com/embed/mQsQ6QZ4dGg" frameborder="0" allowfullscreen=""/>
<xhtml:p>I've also <xhtml:a href="/slides/2012-10-25-BeautifulSoftware/BeautifulSoftware.html">posted
the slides</xhtml:a>.</xhtml:p>
</xhtml:div>
    </content>
  </entry>
  <entry xmlns:xhtml="http://www.w3.org/1999/xhtml">
    <title type="html"><![CDATA[On Visibility in OOP]]></title>
    <published>2012-06-29T02:20:00+0000</published>
    <updated>2012-06-30T15:00:00+0000</updated>
    <link rel="alternate" type="text/html" href="http://mwop.net/blog/2012-06-28-oop-visibility.html"/>
    <id>http://mwop.net/blog/2012-06-28-oop-visibility.html</id>
    <author>
      <name>Matthew Weier O'Phinney</name>
      <email>me@mwop.net</email>
      <uri>http://mwop.net</uri>
    </author>
    <content xmlns:xhtml="http://www.w3.org/1999/xhtml" type="xhtml">
      <xhtml:div xmlns:xhtml="http://www.w3.org/1999/xhtml"><xhtml:p>I'm a big proponent of object oriented programming. OOP done
right helps ease code maintenance and enables code re-use.</xhtml:p>
<xhtml:p>Starting in PHP, OOP enthusiasts got a whole bunch of new tools,
and new tools keep coming into the language for us with each minor
release. One feature that has had a huge impact on frameworks and
libraries has been available since the earliest PHP 5 versions:
visibility.</xhtml:p>
<xhtml:h2>Theory</xhtml:h2>
<xhtml:p>The visibility keywords include <xhtml:em>private</xhtml:em>,
<xhtml:em>protected</xhtml:em>, and <xhtml:em>public</xhtml:em>, often referred to as
<xhtml:strong>PPP</xhtml:strong>. There's an additional keyword I often lump in
with them, <xhtml:em>final</xhtml:em>.</xhtml:p>
<xhtml:p>Public visibility is the default, and equivalent to the only
visibility available to PHP prior to version 5: any member declared
public is accessible from any scope. This means the following:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="php" xml:lang="php">
class Foo
{
    public $bar = 'bar';

    public function baz() 
    {
        // I can access within my own scope
        return $this-&gt;bar;
    }
}

class FooBar extends Foo
{
    public function doThat()
    {
        // I have access to members in my parent
        return $this-&gt;bar . $this-&gt;baz();
    }
}

$foo = new Foo();

// I can access public members from an instance
echo $foo-&gt;bar . $foo-&gt;baz();
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>Basically, public visibility means that I can access the member
from within the object, within an extending class, or from simply
an instance.</xhtml:p>
<xhtml:p>Protected visibility starts to tighten things down a little.
With protected visibility, only the class itself, or an extending
class, can access the member:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="php" xml:lang="php">
class Foo
{
    protected $bar = 'bar';

    protected function baz() 
    {
        // I can access within my own scope
        return $this-&gt;bar;
    }
}

class FooBar extends Foo
{
    public function doThat()
    {
        // I can access protected members in my parent
        return $this-&gt;bar . $this-&gt;baz();
    }
}

$foo = new FooBar();

// This works, as I'm calling a public member of an extending class:
$foo-&gt;doThat();

// But these are both illegal:
echo $foo-&gt;bar . $foo-&gt;baz();
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>Protected visibility is nice for hiding things from those
consuming your class. It can be used to hide implementation
details, and to prevent direct modification of public properties --
something important to consider, if a property may be the product
of calculation, or if a particular type is required.</xhtml:p>
<xhtml:p>Private visibility locks things down further. With private
visibility, the object member is only directly modifiable or
callable within the declaring class.</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="php" xml:lang="php">
class Foo
{
    private $bar = 'bar';

    private function baz() 
    {
        // I can access within my own scope
        return $this-&gt;bar;
    }
}

class FooBar extends Foo
{
    public function doThat()
    {
        // These are both illegal
        return $this-&gt;bar . $this-&gt;baz();
    }
}

$foo = new FooBar();

// These are also both illegal:
echo $foo-&gt;bar . $foo-&gt;baz();
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>Private visibility is generally of interest for locking down
algorithms. For instance, if you know that a particular value or
operation must not change, even in extending classes, declaring the
member private ensures that extending classes cannot directly call
it.</xhtml:p>
<xhtml:p>At any point, you can redeclare a property in an extending class
using equal or more public visibility. The effect of doing so
depends on what the visibility of the member was in the parent
class.</xhtml:p>
<xhtml:ul>
<xhtml:li>
<xhtml:p>In the case of a <xhtml:em>public</xhtml:em> property, if an extending class
re-declares with public visibility, any access to the member within
the extending class or an instance of the extending class will see
only the new declaration.</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="php" xml:lang="php">
class Foo
{
    public $bar = 'bar';

    public function baz() 
    {
        return $this-&gt;bar;
    }
}

class FooBar extends Foo
{
    public $bar = 'foobar';
}

$foo = new FooBar();
echo $foo-&gt;bar;   // "foobar"
echo $foo-&gt;baz(); // "foobar"
        </xhtml:code>
</xhtml:pre></xhtml:div>
</xhtml:li>
<xhtml:li>
<xhtml:p>In the instance of a <xhtml:em>protected</xhtml:em> property, if the
extending class re-declares with either public or protected
visibility, you get the same behavior as public -&gt; public.</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="php" xml:lang="php">
class Foo
{
    protected $bar = 'bar';

    public function baz() 
    {
        return $this-&gt;bar;
    }
}

class FooBar extends Foo
{
    public $bar = 'foobar';
}

$foo = new FooBar();
echo $foo-&gt;bar;   // "foobar"
echo $foo-&gt;baz(); // "foobar"
        </xhtml:code>
</xhtml:pre></xhtml:div>
</xhtml:li>
<xhtml:li>
<xhtml:p>In the instance of a <xhtml:em>private</xhtml:em> property, things get
interesting. The private value or method will be used for any
access made within code declared in the parent class, but not
overridden in the child. However, if the child class overrides any
code, the value of the re-declared instance will be used. This is
far easier to understand via an example.</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="php" xml:lang="php">
class Foo
{
    private $bar = 'bar';
    private $baz = 'baz';

    public function baz() 
    {
        return $this-&gt;bar;
    }
}

class FooBar extends Foo
{
    protected $bar = 'foobar';
    private $baz = 'foobaz';

    public function myBaz() 
    {
        return $this-&gt;bar;
    }

    public function myBaz2()
    {
        return $this-&gt;baz;
    }
}

$foo = new FooBar();
echo $foo-&gt;baz();    // "bar"
echo $foo-&gt;myBaz();  // "foobar"
echo $foo-&gt;myBaz2(); // "foobaz"
        </xhtml:code>
</xhtml:pre></xhtml:div>
</xhtml:li>
</xhtml:ul>
<xhtml:p>My personal takeaway from this is:</xhtml:p>
<xhtml:ul>
<xhtml:li>Use <xhtml:em>public</xhtml:em> for members that are safe for anything to
call.</xhtml:li>
<xhtml:li>Use <xhtml:em>protected</xhtml:em> for anything you don't want called from
instance methods, not important to the public API (implementation
details), and anything you feel is safe for extending classes to
muck about with.</xhtml:li>
<xhtml:li>Use <xhtml:em>private</xhtml:em> for any important implementation details
that could adversely affect execution if overridden by an extending
class.</xhtml:li>
</xhtml:ul>
<xhtml:p>Those paying attention will note that I skipped <xhtml:em>final</xhtml:em>.
Actually, I saved that for last. Marking a class or method
<xhtml:em>final</xhtml:em> tells PHP that the class or method may not be
extended or re-declared/overridden. At all. I lump this with
visibility, because it's another way of locking down access to an
API; marking something <xhtml:em>final</xhtml:em> is saying, "you cannot extend
this", similar to using <xhtml:em>private</xhtml:em>, but without even the
possibility of redeclaring.</xhtml:p>
<xhtml:h2>Applied</xhtml:h2>
<xhtml:p>What got me to thinking about all this was a turn of events with
Zend Framework 2. We've had an annotation parser since last summer.
<xhtml:a href="http://ralphschindler.com/">Ralph Schindler</xhtml:a> developed
it in order to facilitate automatic discovery of injection points
for our Dependency Injection container. Classes could mark a method
with the "Inject" annotation, and the various DI compilers would
know that that method needed to be injected.</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="php" xml:lang="php">
use Zend\Di\Definition\Annotation\Inject;

class Foo
{
    protected $bar;

    /**
     * @Inject()
     * @param  Bar $bar
     * @return void
     */
    public function setBar(Bar $bar)
    {
        $this-&gt;bar = $bar;
    }
}

class Bar {}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>Recently, part of our Forms RFC included a feature to allow
creating forms and their related input filters by using
annotations. Basically, this allows developers to hint on their
domain entities how specific properties should be filtered,
validated, and potentially represented at the form level.</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="php" xml:lang="php">
use Zend\Form\Annotation;

class Foo
{
    /**
     * @Annotation\Filter({"name":"StringTrim"})
     * @Annotation\Validator({"name":"Between","options":{"min":5,"max":20}})
     * @Annotation\Attributes({"type":"range"})
     */
    protected $bar;
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>One developer testing the support wanted to use a combination of
<xhtml:a href="http://doctrine-project.org">Doctrine</xhtml:a> annotations and
ZF2 form annotations -- that way his entities could also describe
validation and representation.</xhtml:p>
<xhtml:p>I did some work to make this happen, and everybody was happy.
Except then that same developer went to use that entity with
Doctrine, and Doctrine's annotation parser started raising
exceptions on all the ZF2 annotations.</xhtml:p>
<xhtml:p>After some debate, I realized: (a) we were basically just making
up syntax for our annotations; it'd be better to use an established
syntax; but (b) we should still retain the ability to use arbitrary
syntax, as we can't really know what sorts of annotations
developers may already be using.</xhtml:p>
<xhtml:p>So, we decided to make our annotation component depend on the
annotations support in Doctrine\\Common, and to use the annotation
syntax they utilize. ZF2 would provide some code to make it
possible to plug in arbitrary parsers, and use the Doctrine\\Common
annotation parser to parse annotations officially supported by
ZF2.</xhtml:p>
<xhtml:p>However, when I went to start making this happen, I ran into
immediate issues.</xhtml:p>
<xhtml:p>Remember how this post is about visibility? Well, the class I
was directly interested in,
<xhtml:code>Doctrine\Common\Annotations\DocParser</xhtml:code>, not only
contains private members, but is marked <xhtml:em>final</xhtml:em>.</xhtml:p>
<xhtml:p>My immediate response was to start dissecting the class, cutting
and pasting the bits interesting to my solution into a new class in
ZF2. I went down this route for several hours, gradually pulling in
more and more methods as I discovered how far down the rabbit hole
I needed to go to accomplish my task.</xhtml:p>
<xhtml:p>But at the back of my head, I kept thinking this was a bad idea.
If any patches ever came in for the original class, I'd need to
port them into our ZF2 solution. And I couldn't help but think that
I'd miss a crucial piece.</xhtml:p>
<xhtml:p>So I started playing with its public API, to see if there were
any shortcuts I might be able to take. And there were.</xhtml:p>
<xhtml:p>The class has a public <xhtml:code>parse()</xhtml:code> method. Based on how
Doctrine uses the code, I assumed I needed to pass a full PHP
docblock in -- which ran counter to how I wanted to use the code. I
wanted to pass in an annotation at a time. But when I looked
closer, I realized that the parser didn't require a full docblock;
any fragment would do.</xhtml:p>
<xhtml:p>To make a long story short: I was able to feed the parser a
single annotation at a time from ZF2's
<xhtml:code>AnnotationScanner</xhtml:code>. This allowed me to build a very
simple class that allows registering a set of annotations it can
handle, and feeding it a single annotation string at a time to
decide (a) if it supports it, and (b) to parse it and return the
associated annotation object.</xhtml:p>
<xhtml:p>In sum: because the class in question was marked final and had
private members, I found myself forced to think critically about
what I wanted to accomplish, and then thoroughly understand the
public API to see how I might accomplish that task without the
ability to extend.</xhtml:p>
<xhtml:h2>Conclusions</xhtml:h2>
<xhtml:p>Doctrine has a policy that encourages <xhtml:a href="http://en.wikipedia.org/wiki/Poka-yoke"><xhtml:em>poka-yoke</xhtml:em></xhtml:a>
solutions: code should be executable in a specific way. The policy
was developed to both aid users (having multiple ways of doing
something is often confusing), as well as to ease maintenance
(fewer extension points means less liklihood of developers doing
hard-to-debug things in extending code and reporting it back to the
project). These have led them to heavily use <xhtml:em>private</xhtml:em> and
<xhtml:em>final</xhtml:em> visibility.</xhtml:p>
<xhtml:p>I've said it before, and I'll say it again: I feel that
frameworks and libraries should use <xhtml:em>private</xhtml:em> and
<xhtml:em>final</xhtml:em> sparingly. Over the years, I've seen code repurposed
in simply wondrous ways -- largely due to keeping the code as open
as possible to extension. I like to enable my users as much as
possible.</xhtml:p>
<xhtml:p>That said, I can also see Doctrine's argument -- and can see
where, while it can often be frustrating, it can also lead to
potentially more sound and elegant solutions.</xhtml:p>
<xhtml:p>I'll probably continue shying away from <xhtml:em>private</xhtml:em> and
<xhtml:em>final</xhtml:em> visibility, but I do plan to experiment with it more
in the future. What about you?</xhtml:p>
</xhtml:div>
    </content>
  </entry>
  <entry xmlns:xhtml="http://www.w3.org/1999/xhtml">
    <title type="html"><![CDATA[On Error Handling and Closures]]></title>
    <published>2011-12-16T16:26:18+0000</published>
    <updated>2011-12-16T16:26:18+0000</updated>
    <link rel="alternate" type="text/html" href="http://mwop.net/blog/on-error-handling-and-closures.html"/>
    <id>http://mwop.net/blog/on-error-handling-and-closures.html</id>
    <author>
      <name>Matthew Weier O'Phinney</name>
      <email>me@mwop.net</email>
      <uri>http://mwop.net</uri>
    </author>
    <content xmlns:xhtml="http://www.w3.org/1999/xhtml" type="xhtml">
      <xhtml:div xmlns:xhtml="http://www.w3.org/1999/xhtml"><xhtml:p>The error suppression operator in PHP ("@") is often seen as a
necessary evil. Many, many low-level function will return a value
indicating an error, but also raise an <xhtml:code>E_NOTICE</xhtml:code> or
<xhtml:code>E_WARNING</xhtml:code> -- things you might be able to recover from,
or conditions where you may want to raise an exception.</xhtml:p>
<xhtml:p>So, at times, you find yourself writing code like this:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="php" xml:lang="php">
if (false === ($fh = @fopen($filename, 'r'))) {
    throw new RuntimeException(sprintf(
        'Could not open file "%s" to read', $filename
    ));
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>Seems straight-forward enough, right? But it's wrong on so many
levels.</xhtml:p>
<xhtml:ul>
<xhtml:li>The error doesn't magically go away. If you've got PHP's log
setup, you're going to be getting a log entry each time the
suppressed statement errors.</xhtml:li>
<xhtml:li>Error suppression is expensive. Like, really, really expensive.
A special error handler is registered to prevent the error
propagating to the display (if <xhtml:code>display_errors</xhtml:code> is
enabled), but errors are still sent to the log (as noted above).
When done, the original error handler has to be restored.</xhtml:li>
<xhtml:li>If you use things like <xhtml:code>error_get_last()</xhtml:code>, you may
find that if you have many error suppressions, it returns something
unrelated to the error that just occurred.</xhtml:li>
<xhtml:li>PHPUnit, anyone? Error suppression and PHPUnit do not play well
together. And there's a reason for that: often suppressed errors
are indicative of bigger issues.</xhtml:li>
</xhtml:ul>
<xhtml:p>So, how do you address it?</xhtml:p>
<xhtml:p>PHP has two functions to assist with this:
<xhtml:code>set_error_handler()</xhtml:code> and
<xhtml:code>restore_error_handler()</xhtml:code>. The first takes a callable
argument, and optionally a mask of error levels to which it will
respond; the second is used to return error handling to the
previously set handler.</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="php" xml:lang="php">
function handleError($errno, $errmsg = '', $errfile = '', $errline = 0)
{
    throw new RuntimeException(sprintf(
        'Error reading file (in %s@%d): %s',
        $errfile, $errline, $errmsg
    ), $errno);
}

set_error_handler('handleError', E_WARNING);
$fh = fopen($filename, 'r');
restore_error_handler();
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>Traditionally, these have been a pain to use, as you have to
create individual functions or methods for handlers, and methods
must have public visibility, even if the functionality is internal
to the class.</xhtml:p>
<xhtml:p>With PHP 5.3, we get a new option, however: closures.</xhtml:p>
<xhtml:p>With closures, error handlers are still a pain to use, but you
now get to scope the handlers directly in the context of the
application flow. Let's look at an example:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="php" xml:lang="php">
set_error_handler(
    function($error, $message = '', $file = '', $line = 0) use ($filename) {
        throw new RuntimeException(sprintf(
            'Error reading file "%s" (in %s@%d): %s',
            $filename, $file, $line, $message
        ), $error);
    },
    E_WARNING
);
$fh = fopen($filename, 'r');
restore_error_handler();

</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>If you just want to ignore the error, it's even simpler:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="php" xml:lang="php">
set_error_handler(function() { return true; }, E_NOTICE);
$contents = file_get_contents($filename);
restore_error_handler();
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>The code isn't necessarily succinct, which is one reason many
gravitate towards using error suppression instead. However, it has
the benefit of being context-sensitive and robust, which is always
a good goal.</xhtml:p>
</xhtml:div>
    </content>
  </entry>
  <entry xmlns:xhtml="http://www.w3.org/1999/xhtml">
    <title type="html"><![CDATA[Dependency Injection: An analogy]]></title>
    <published>2011-03-21T21:52:15+0000</published>
    <updated>2011-03-25T06:25:13+0000</updated>
    <link rel="alternate" type="text/html" href="http://mwop.net/blog/260-Dependency-Injection-An-analogy.html"/>
    <id>http://mwop.net/blog/260-Dependency-Injection-An-analogy.html</id>
    <author>
      <name>Matthew Weier O'Phinney</name>
      <email>me@mwop.net</email>
      <uri>http://mwop.net</uri>
    </author>
    <content xmlns:xhtml="http://www.w3.org/1999/xhtml" type="xhtml">
      <xhtml:div xmlns:xhtml="http://www.w3.org/1999/xhtml"><xhtml:p>I've been working on a proposal for including service locators
and dependency injection containers in Zend Framework 2.0, and one
issue I've had is trying to explain the basic concept to developers
unfamiliar with the concepts -- or with pre-conceptions that
diverge from the use cases I'm proposing.</xhtml:p>
<xhtml:p>In talking with my wife about it a week or two ago, I realized
that I needed an analogy she could understand; I was basically
using her as my <xhtml:a href="http://en.wikipedia.org/wiki/Rubber_duck_debugging">rubber
duck</xhtml:a>. And it turned out to be a great idea, as it gave me some
good analogies.</xhtml:p>
<xhtml:h2 id="toc_1.1">Dining Out</xhtml:h2>
<xhtml:p>The analogies go like this: you walk into a burger join, and
you're hungry.</xhtml:p>
<xhtml:ul>
<xhtml:li>Dependency Injection is like ordering off the menu -- but
specifying things like, "I'd like to substitute portabella
mushrooms for the patties, please." The waiter then goes and brings
your dish, which has portabella mushrooms instead of the hamburger
patties listed on the menu.</xhtml:li>
<xhtml:li>Service Location is like ordering with substitutions, and
having the waiter completely ignore the substitutions; you get
what's on the menu, nothing more, nothing less.</xhtml:li>
</xhtml:ul>
<xhtml:p>Now, when it comes to Zend Framework's version 1 releases, we've
really got neither. Our situation is more like a buffet or a
kitchen -- you grab a little of this, a little of that, and
assemble your own burger. It's a lot more work.</xhtml:p>
<xhtml:p>Frankly, I'm lazy, and like my dinner brought to me... and if I
want any substitutions, I'd like those, too.</xhtml:p>
<xhtml:h2 id="toc_1.2">Getting the Ingredients</xhtml:h2>
<xhtml:p>A number of developers I've talked to seem to think DI is a bit
too much "magic" -- they're worried they'll lose control over their
application: they won't know where dependencies are being set.</xhtml:p>
<xhtml:p>There are two things to keep in mind:</xhtml:p>
<xhtml:ol>
<xhtml:li>you, the developer, define the dependencies up front</xhtml:li>
<xhtml:li>if you don't pull the object from the container, you're in
charge</xhtml:li>
</xhtml:ol>
<xhtml:p>Regarding the second point, it appears some developers think
that with a DI container in place, dependencies magically get
injected in <xhtml:em>every</xhtml:em> object. But that's simply not the case.
If you use normal PHP:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="php" xml:lang="php">
$o = new SomeClass();
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>you'll get a new instance, just like always, configured only
with any parameters you pass in to the constructor or methods you
call on it. It's only when you retrieve the object from the DI
container that you dependency injection takes place; if you do
that, you can always examine the DI configuration (which can either
be programmatic or via a configuration file) to determine what
dependencies were configured.</xhtml:p>
<xhtml:p>Basically, it's like the difference between making your own
hamburger patty out of fresh ground sirloin, and ordering Animal
Style from In-N-Out.</xhtml:p>
<xhtml:h2 id="toc_1.3">I'm done now</xhtml:h2>
<xhtml:p>What's your favorite way of thinking of these concepts?</xhtml:p>
</xhtml:div>
    </content>
  </entry>
  <entry xmlns:xhtml="http://www.w3.org/1999/xhtml">
    <title type="html"><![CDATA[Aspects, Filters, and Signals, Oh, My!]]></title>
    <published>2011-01-10T14:30:00+0000</published>
    <updated>2011-01-14T13:53:52+0000</updated>
    <link rel="alternate" type="text/html" href="http://mwop.net/blog/251-Aspects,-Filters,-and-Signals,-Oh,-My!.html"/>
    <id>http://mwop.net/blog/251-Aspects,-Filters,-and-Signals,-Oh,-My!.html</id>
    <author>
      <name>Matthew Weier O'Phinney</name>
      <email>me@mwop.net</email>
      <uri>http://mwop.net</uri>
    </author>
    <content xmlns:xhtml="http://www.w3.org/1999/xhtml" type="xhtml">
      <xhtml:div xmlns:xhtml="http://www.w3.org/1999/xhtml"><xhtml:p>Last month, during <xhtml:a href="http://phpadvent.org">PHP
Advent</xhtml:a>, <xhtml:a href="http://ohloh.net/accounts/gwoo">gwoo</xhtml:a> wrote
an interesting post on <xhtml:a href="http://phpadvent.org/2010/aspect-oriented-design-by-garrett-woodworth">
Aspect-Oriented Design</xhtml:a>, or Aspect Oriented Programming (AOP) as
it is more commonly known. The article got me to thinking, and
revisiting what I know about AOP, Intercepting Filters, and Signal
Slots -- in particular, what use cases I see for them, what the
state of current PHP offerings are, and where the future may
lie.</xhtml:p>
<xhtml:p>But first, some background is probably in order, as this is a
jargon-heavy post.</xhtml:p>
<xhtml:h2 id="toc_1.1">Aspect Oriented Programming</xhtml:h2>
<xhtml:p>I was first introduced to AOP in 2006 via an <xhtml:a href="http://www.phparch.com/magazine/2006-2/april/">April 2006
php|architect article by Dmitry Sheiko</xhtml:a>. That article detailed
adding calls at various places in a method where you might want to
hook into functionality -- for instance, to log, cache, etc.
Expanding on this, I considered other possibilities: manipulating
incoming arguments, validation, ACL checks, implementing
write-through caching strategies, and more. The approach is
daunting, however; typical, naive implementations lead to a lot of
boiler-plate code:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="php" xml:lang="php">
interface Listener
{
    public function notify($signal, $argv = null);
}

class Foo
{
    protected $listeners;

    public function attach($signal, Listener $listener)
    {
        $this-&gt;listeners[$signal][] = $listener;
    }

    public function doSomething($arg1, $arg2)
    {
        foreach ($this-&gt;listeners as $listener) {
            $listener-&gt;notify('preDoSomething', func_get_args());
        }
        
        // do some work
        
        foreach ($this-&gt;listeners as $listener) {
            $listener-&gt;notify('postDoSomething', $result);
        }
    }
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>The article didn't go into any real details on how you might
short-circuit the filters or handle return values from them, and
aspect handling itself was not detailed completely. As such, the
code begins to add up, particularly if many classes and/or methods
implement the functionality.</xhtml:p>
<xhtml:h2 id="toc_1.2">Intercepting Filters</xhtml:h2>
<xhtml:p>A similar concept to AOP is the idea of <xhtml:a href="http://java.sun.com/blueprints/corej2eepatterns/Patterns/InterceptingFilter.html">
Intercepting</xhtml:a> <xhtml:a href="http://msdn.microsoft.com/en-us/library/ff647251.aspx">Filters</xhtml:a>.
Like AOP, the idea is to separate cross-cutting concerns such as
logging, debugging, and more from the actual logic the component
exposes. The difference is that typically Intercepting Filters are
language independent, have a standard implementation in a given
framework, and can be re-used. The approach gwoo used in his post
falls more under this category.</xhtml:p>
<xhtml:p><xhtml:a href="http://lithify.me/">Lithium</xhtml:a>, a PHP 5.3 framework
and the reference for gwoo's article, has a very intriguing
approach. Instead of calling the filters explicitly within the body
of the code, they suggest that the body of the code simply becomes
one of the filters, via a closure:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="php" xml:lang="php">
Dispatcher::applyFilter('run', function ($self, $params, $chain) {
    // do something...
    return $chain-&gt;next($self, $params, $chain);
});
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>In Lithium, each filter is responsible for calling the next
(each filter receives the chain as its third and final argument);
as soon as one doesn't call <xhtml:code>next()</xhtml:code>, execution is
stopped, and the result returned (or at least that's how I read the
source). You can call the chain either before or after the code you
want to execute in each filter; placement will determine whether
it's a pre- or a post-filter. The approach answers a number of the
concerns I outlined previously -- namely, standardization of
approach, and the ability to short-circuit execution.</xhtml:p>
<xhtml:p>The above example defines a filter that will run when the
<xhtml:code>run()</xhtml:code> method of the <xhtml:code>Dispatcher</xhtml:code> class is
executed. <xhtml:code>$self</xhtml:code> will typically be the object instance,
<xhtml:code>$params</xhtml:code> an array of the parameters passed to the
method, and <xhtml:code>$chain</xhtml:code> as described above. The method
itself will execute any filters -- typically with something like
this:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="php" xml:lang="php">
use lithium/core/Object as BaseObject;

class Foo extends BaseObject
{
    public function doSomething($with, $these, $args)
    {
        $params = compact('with', 'these', 'args');
        
        return $this-&gt;_filter(__METHOD__, $params, function ($self, $params) {
            // do the actual work here
            return $result;
        });
    }
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>(The <xhtml:code>_filter()</xhtml:code> method is defined in
<xhtml:code>lithium\core\Object</xhtml:code>, and basically passes a local,
static chain of filters to Lithium's <xhtml:code>Filter</xhtml:code> class for
execution. <xhtml:code>applyFilter()</xhtml:code> from the previous example
statically adds a callback under the named method to the
chain.)</xhtml:p>
<xhtml:p>This solution is elegant -- but I see some limitations:</xhtml:p>
<xhtml:ul>
<xhtml:li>First and foremost, I'm not particularly fond of the filtering
functionality being via static methods on a single class; it
introduces a hard-coded, hidden dependency. This means you cannot
provide alternate filtering functionality without extending the
class <xhtml:em>consuming</xhtml:em> the filters, nor without either extending
the base filters implementation should you wish to provide a
compatible API (for instance, to introduce an implementation that
understands priorities).<xhtml:br/>
<xhtml:br/>
Additionally, the easiest way to implement filtering in Lithium is
by extending the <xhtml:code>lithium\core\Object</xhtml:code> class -- I could
find no examples elsewhere in the documentation that showed how you
would compose the <xhtml:code>Filters</xhtml:code> implementation in your own
objects. As such, the easiest way to compose filters is now via
inheritance, which seems to be counter-productive to the whole
rationale behind filtering, to my thinking.</xhtml:li>
<xhtml:li>Second, the approach of making the body of the calling method a
closure makes it difficult to create non-public helper methods.
Inside the filter, you're no longer in the scope of the object,
losing the semantics that tie the various metadata and
functionality of the object together. (The Lithium docs provide
illustrations of how to accomplish this, but they require extra
work, and a keen understanding of how references work in PHP.)</xhtml:li>
<xhtml:li>Third, it's sometimes useful to have access to the return
results of <xhtml:em>all</xhtml:em> the filters (not just the last executed);
you may want to aggregate them in some way, or branch logic based
on the various returns.</xhtml:li>
<xhtml:li>Fourth, it's sometimes useful to have multiple call points
within the main code. As an example, for many caching strategies,
you'd check first to see if you have a cache hit, and return
immediatly if found; otherwise, you'd execute the code, and cache
the result prior to returning it. This might be possible in Lithium
with constructs like this:
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="php" xml:lang="php">
Filters::add('SomeClass::doSomething', function ($method, $self, $params) {
    if (null !== ($content = cache_hit($params))) {
        return $content;
    }
    $content = Filters::next($method, $self, $params);
    return $content;
});
</xhtml:code>
</xhtml:pre></xhtml:div>
However, if you have several filters such as this, the order then
becomes paramount, and that introduces new complexities.<xhtml:br/>
<xhtml:br/>
Another example would be with fa√ßade methods, where you may wish to
introduce filters before and after each method call:
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="php" xml:lang="php">
    public function doSomeWorkflow($message)
    {
        $this-&gt;somePrivateMethod($message);
        $this-&gt;nextPrivateMethod($message);
        $this-&gt;lastPrivateMethod($message);
    }
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:br/>
<xhtml:br/>
(I can already hear <xhtml:a href="http://nateabele.com/">Nate</xhtml:a> saying
"make those all filters!" or "filter each method!" -- but that's
the problem with simple examples - they can't always express the
nuances of a use case.)</xhtml:li>
<xhtml:li>Fifth, it's useful to be able to attach callbacks that are not
aware of the chain. For instance, you may have code you've already
written that works perfectly fine in a standalone situation --
e.g., a logger -- and you simply want to add it to the chain. In
the Lithium paradigm, you'd need to <xhtml:a href="http://en.wikipedia.org/wiki/Currying">curry</xhtml:a> the calls in,
instead of simply using the existing method:
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="php" xml:lang="php">
// This:
SomeClass::applyFilter('doSomething', function ($self, $params, $chain) use ($log) {
    $log-&gt;info($params['message'];
    $chain-&gt;next($self, $params, $chain);
});
// VS:
SomeClass::signals()-&gt;connect('doSomething', $log, 'info');
</xhtml:code>
</xhtml:pre></xhtml:div>
Related to this, I personally dislike aggregating the filter
parameters into a single associative array. I don't like having to
test for the existence of parameters, and would much rather PHP
tell me if I'm missing required parameters or if any fail
typehints. That said, doing so provides a consistent API when
filtering.</xhtml:li>
</xhtml:ul>
<xhtml:p>All in all, however, the approach Lithium provides is very good;
it just doesn't completely suit my tastes or use cases.</xhtml:p>
<xhtml:h2 id="toc_1.3">Signal Slots</xhtml:h2>
<xhtml:p>Interestingly, the capabilities I need are not far from what
Lithium provides -- in fact, I'd argue that the Intercepting
Filters of Lithium are actually probably more akin to another
pattern, <xhtml:a href="http://en.wikipedia.org/wiki/Signals_and_slots">Signal
Slots</xhtml:a>.</xhtml:p>
<xhtml:p>With Signal Slots, your code emits <xhtml:em>signals</xhtml:em> (Lithium
does this -- it emits the name of the method being called); any
handler, or <xhtml:em>slot</xhtml:em> (<xhtml:em>filters</xhtml:em> in Lithium), connected
to the signal is then executed.</xhtml:p>
<xhtml:p>As such, you typically have some sort of signal "manager" object
(the <xhtml:code>Filters</xhtml:code> class in Lithium) that aggregates signals
and attached slots; this manager is then composed into the object
emitting signals. For those of you familiar with events in
JavaScript or other event-driven languages, this should sound quite
familiar.</xhtml:p>
<xhtml:p>Such an approach looks like this:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="php" xml:lang="php">
class Foo
{
    protected $signals;

    public function signals(SignalSlot $signals = null)
    {
        if (null === $signals) {
            // No argument? make sure we have a signal manager
            if (null === $this-&gt;signals) {
                $this-&gt;signals = new Signals(); // SignalSlot implementation
            }
        } else {
            // Compose in an instance of a signal manager
            $this-&gt;signals = $signals;
        }
        return $this-&gt;signals;
    }

    public function doSomething($with, $these, $args)
    {
        $this-&gt;signals()-&gt;emit('doSomething.pre', $this, $with, $these, $args);
        
        // do some work
        $this-&gt;signals()-&gt;emit('doSomething.during', $this, $with, $these, $args);

        // do some more work
        // This time, pass the result
        $this-&gt;signals()-&gt;emit('doSomething.post', $this, $result, $with, $these, $args);
        return $result;
    }
}

$f = new Foo();
$f-&gt;signals()-&gt;connect('doSomething.pre', $log, 'info');
$f-&gt;signals()-&gt;connect('doSomething.during', $validator, 'isValid');
$f-&gt;signals()-&gt;connect('doSomething.post', $indexer, 'index');
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>Basically, a <xhtml:code>SignalSlot</xhtml:code> provides an object in which
signals and their attached slots are aggregated. This allows having
a single manager for multiple signals (which is similar to how
Lithium's <xhtml:code>Filters</xhtml:code> class works), while also providing a
way to emit multiple signals from a single procedure. Additionally,
since it is simply an object, you can compose it in to classes that
may emit signals -- without requiring inheritance.</xhtml:p>
<xhtml:p>This is the basic approach of the <xhtml:a href="https://github.com/zendframework/zf2/tree/master/library/Zend/SignalSlot">
ZF2 SignalSlot implementation</xhtml:a>, as well as that found in
<xhtml:a href="http://components.symfony-project.org/event-dispatcher/">Symfony
2's Event Dispatcher</xhtml:a> and <xhtml:a href="http://incubator.apache.org/zetacomponents/documentation/trunk/SignalSlot/tutorial.html">
Zeta Components' SignalSlot component</xhtml:a>.</xhtml:p>
<xhtml:p>Both Symfony 2's Event Dispatcher and ZF2's
<xhtml:code>SignalSlot</xhtml:code> component build in the ability to
short-circuit, Symfony via a <xhtml:code>notifyUntil()</xhtml:code> method, and
ZF2 via an <xhtml:code>emitUntil</xhtml:code> method. With ZF2, each time a
signal is emitted, a <xhtml:code>ResponseCollection</xhtml:code> is returned by
the manager, containing an aggregate of all slot responses. Calling
<xhtml:code>emitUntil()</xhtml:code> will short-circuit execution of remaining
slots if a given slot returns a response that validates against
given criteria; at this point, the collection is marked as
"stopped", and you can pull the "last" response and return it:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="php" xml:lang="php">
$responses = $this-&gt;signals()-&gt;emitUntil(function($response) {
    return ($response instanceof SpecificResultType);
}, 'doSomething.pre', $this, $with, $these, $args);
if ($responses-&gt;stopped()) {
    return $responses-&gt;last();
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>This introduces extra code in the method emitting the signals --
but meets the criteria that no given slot need be aware of the
chain.</xhtml:p>
<xhtml:p>The Signal Slot approach actually supports paradigms similar to
those illustrated in Lithium. For instance, I can make my method
body a slot:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="php" xml:lang="php">
class Foo
{
    protected $handlers = array();

    // ... skip signals composition ...
    
    public function doSomething($with, $these, $args)
    {
        $params = compact('with', 'these', 'args');
        
        // connect() returns a signal handler (slot); store it so that we only
        // ever attach it once...
        if (isset($this-&gt;handlers[__FUNCTION__])) {
            $this-&gt;handlers[__FUNCTION__] = $this-&gt;signals()-&gt;connect(__FUNCTION__, function($self, $params) {
                // do the work here!
            });
        }
        
        // Emit the signal, and return the last result
        return $this-&gt;signals()-&gt;emit(__FUNCTION__, $this, $params)-&gt;last();
    }
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:h2 id="toc_1.4">Concerns</xhtml:h2>
<xhtml:p>Using Signal Slots and Intercepting Filters is not without its
concerns, nor is any given implementation perfect.</xhtml:p>
<xhtml:ul>
<xhtml:li>Zeta Components does a fantastic job of handling signal slots.
However, you cannot short-circuit execution, nor introspect return
values. It does offer two features neither ZF2 nor Symfony 2 offer
(at this time): the ability to <xhtml:em>statically</xhtml:em> connect slots to
signals, allowing you to wire without having an existing instance,
nor even caring what object might emit the signal; and the ability
to add a priority to slots, which allows you to alter the execution
order.</xhtml:li>
<xhtml:li>Lithium does a nice job of providing good standards (signals
are method names; parameters are predictable for all handlers), but
at the price of some flexibility (static implementation with no
interface for alternate implementations; no ability to re-use
existing methods and functions with differing signatures without
currying).</xhtml:li>
<xhtml:li>Symfony 2 offers short-ciruiting and flexibility in callbacks,
but requires that you create an event object to pass to the Event
Dispatcher, making the usage slightly more verbose, and offers no
standardization of signal naming.</xhtml:li>
<xhtml:li>ZF2's <xhtml:code>SignalSlots</xhtml:code> offer similar benefits (and
drawbacks) to Symfony 2's implementation, provides standardization
of the signal manager response, allows registering classes that
self-register with the signal handler, but lacks static wiring
capabilities or prioritization.</xhtml:li>
</xhtml:ul>
<xhtml:p>On a more abstract level, signal slots and intercepting filters
can lead to difficulties in learning and mastering code that use
them:</xhtml:p>
<xhtml:ul>
<xhtml:li>How are signals named?</xhtml:li>
<xhtml:li>How do you document the parameters available to
slots/filters?</xhtml:li>
<xhtml:li style="list-style: none; display: inline">
<xhtml:ul>
<xhtml:li>How can those using IDEs discover available signals? and the
arguments expected?</xhtml:li>
</xhtml:ul>
</xhtml:li>
<xhtml:li>Where does the wiring occur?</xhtml:li>
<xhtml:li style="list-style: none; display: inline">
<xhtml:ul>
<xhtml:li>For instance, if any wiring is automated, this can potentially
lead to more difficulty in debugging.</xhtml:li>
<xhtml:li>If done manually, when, and where?</xhtml:li>
</xhtml:ul>
</xhtml:li>
<xhtml:li>What happens if a slot doesn't receive arguments it needs, or
cannot handle the arguments it receives?</xhtml:li>
</xhtml:ul>
<xhtml:p>In short, while they solve many problems, the implementations
also introduce new concerns -- though this will be true of any
extension system, in my experience.</xhtml:p>
<xhtml:h2 id="toc_1.5">Conclusions</xhtml:h2>
<xhtml:p>I personally am a huge fan of Intercepting Filters and Signal
Slots. I think they can make code easier to extend, by providing a
standard methodology for introducing cross-cutting concerns without
requiring class extension. They can also make code quite expressive
-- sometimes at the cost of readability -- by introducing
functional programming paradigms.</xhtml:p>
<xhtml:p>If you have not investigated these concepts or components
before, I highly recommend doing so; I think they play a
fundamental role in the next generation of PHP frameworks.</xhtml:p>
<xhtml:h2 id="toc_1.6">Caveats</xhtml:h2>
<xhtml:p>I am not an expert, nor well-versed, in all the frameworks
listed here, and as such, some of the information may be incorrect
or incomplete. I am the author of ZF2's current Signal Slot
implementation, and am still working on improvements to it.</xhtml:p>
<xhtml:h2>Updates</xhtml:h2>
<xhtml:ul>
<xhtml:li><xhtml:b>2011-01-10 11:35Z-05:00</xhtml:b> Cal Evans found the original
php|architect article I referenced, and I've revised some of the
assessments based on re-reading it, as well as linked to the
issue.</xhtml:li>
</xhtml:ul>
</xhtml:div>
    </content>
  </entry>
  <entry xmlns:xhtml="http://www.w3.org/1999/xhtml">
    <title type="html"><![CDATA[Setting up your Zend_Test test suites]]></title>
    <published>2008-09-11T19:00:00+0000</published>
    <updated>2008-09-13T13:37:40+0000</updated>
    <link rel="alternate" type="text/html" href="http://mwop.net/blog/190-Setting-up-your-Zend_Test-test-suites.html"/>
    <id>http://mwop.net/blog/190-Setting-up-your-Zend_Test-test-suites.html</id>
    <author>
      <name>Matthew Weier O'Phinney</name>
      <email>me@mwop.net</email>
      <uri>http://mwop.net</uri>
    </author>
    <content xmlns:xhtml="http://www.w3.org/1999/xhtml" type="xhtml">
      <xhtml:div xmlns:xhtml="http://www.w3.org/1999/xhtml"><xhtml:p>Now that <xhtml:a href="http://framework.zend.com/manual/en/zend.test.html">Zend_Test</xhtml:a>
has shipped, developers are of course asking, "How do I setup my
test suite?" Fortunately, after some discussion with my colleagues
and a little experimenting on my one, I can answer that now.</xhtml:p>
<xhtml:p><xhtml:a href="http://phpunit.de">PHPUnit</xhtml:a> offers a variety of
methods for setting up test suites, some trivial and some complex.
The Zend Framework test suite, for instance, goes for a more
complex route, adding component-level suites that require a fair
amount of initial setup, but which allow us fairly fine-grained
control.</xhtml:p>
<xhtml:p>However, testing and test automation should be easy and the
complex approach is overkill for most of our applications.
Fortunately, PHPUnit offers some other methods that make doing so
relatively simple. The easiest method is to use an <xhtml:a href="http://www.phpunit.de/pocket_guide/3.2/en/appendixes.configuration.html">
XML configuration file</xhtml:a>.</xhtml:p>
<xhtml:p>As an example, consider the following:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="xml" xml:lang="xml">
&lt;phpunit&gt;
    &lt;testsuite name=\"My Test Suite\"&gt;
        &lt;directory&gt;./&lt;/directory&gt;
    &lt;/testsuite&gt;

    &lt;filter&gt;
        &lt;whitelist&gt;
            &lt;directory suffix=\".php\"&gt;../library/&lt;/directory&gt;
            &lt;directory suffix=\".php\"&gt;../application/&lt;/directory&gt;
            &lt;exclude&gt;
                &lt;directory suffix=\".phtml\"&gt;../application/&lt;/directory&gt;
            &lt;/exclude&gt;
        &lt;/whitelist&gt;
    &lt;/filter&gt;

    &lt;logging&gt;
        &lt;log type=\"coverage-html\" target=\"./log/report\" charset=\"UTF-8\"
            yui=\"true\" highlight=\"true\"
            lowUpperBound=\"50\" highLowerBound=\"80\"/&gt;
        &lt;log type=\"testdox-html\" target=\"./log/testdox.html\" /&gt;
    &lt;/logging&gt;
&lt;/phpunit&gt;
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>First thing to note, relative paths are relative to the
configuration file. This allows you to run your tests from anywhere
in your tests tree, Second, providing a <xhtml:code>directory</xhtml:code>
directive to the <xhtml:code>testsuite</xhtml:code> directive scans for all
files ending in "Test.php" in that directory, meaning you don't
have to keep a list of your test cases manually. It's a great way
to automate the suite. Third, the filter directive allows us to
determine what classes to include and/or exclude from coverage
reports. Finally, the <xhtml:code>logging</xhtml:code> directive lets us
specify what kinds of logs to create and where.</xhtml:p>
<xhtml:p>Drop the above into "tests/phpunit.xml" in your application, and
you can start writing test cases and running the suite immediately,
using the following command:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="text" xml:lang="text">
% phpunit --configuration phpunit.xml
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>I like to group my test cases by type. I have controllers,
models, and often library code, and need to keep the tests
organized both on the filesystem as well as for running the actual
tests. There are two things I do to facilitate this.</xhtml:p>
<xhtml:p>First, I create directories. For instance, I have the following
hierarchy in my test suite:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="text" xml:lang="text">
tests/
    phpunit.xml
    TestHelper.php
    controllers/
        IndexControllerTest.php (contains IndexControllerTest)
        ErrorControllerTest.php (contains ErrorControllerTest)
        ...
    models/
        PasteTest.php           (contains PasteTest)
        DbTable/
            PasteTest.php       (contains DbTable_PasteTest)
        ...
    My/
        Form/
            Element/
                SimpleTextareaTest.php
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>"controllers/" contains my controllers, "models/" contains my
models. If I were developing a modular application, I'd have
something like "blog/controllers/" instead. Library code is given
the same hierarchy as is found in my "library/" directory.</xhtml:p>
<xhtml:p>Second, I use docblock annotations to group my tests. I add the
following to my class-level docblock in my controller test
cases:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="php" xml:lang="php">
/**
 * @group Controllers
 */
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>Models get the annotation "@group Models", etc. This allows me
to run individual sets of tests on demand:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="text" xml:lang="text">
% phpunit --configuration phpunit.xml --group Controllers
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>You can specify multiple @group annotations, which means you can
separate tests into modules, issue report identifiers, etc;
additionally, you can add the annotations to individual test
methods themselves to have really fine-grained test running
capabilities.</xhtml:p>
<xhtml:p>Astute readers will have noticed the "TestHelper.php" file in
that directory listing earlier, and will be wondering what that's
all about.</xhtml:p>
<xhtml:p>A test suite needs some environmental information, just like
your application does. It may need a default database adapter,
altered include_paths, autoloading set up, and more. Here's what my
TestHelper.php looks like:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="php" xml:lang="php">
&lt;?php
/*
 * Start output buffering
 */
ob_start();

/*
 * Set error reporting to the level to which code must comply.
 */
error_reporting( E_ALL | E_STRICT );

/*
 * Set default timezone
 */
date_default_timezone_set('GMT');

/*
 * Testing environment
 */
define('APPLICATION_ENV', 'testing');

/*
 * Determine the root, library, tests, and models directories
 */
$root        = realpath(dirname(__FILE__) . '/../');
$library     = $root . '/library';
$tests       = $root . '/tests';
$models      = $root . '/application/models';
$controllers = $root . '/application/controllers';

/*
 * Prepend the library/, tests/, and models/ directories to the
 * include_path. This allows the tests to run out of the box.
 */
$path = array(
    $models,
    $library,
    $tests,
    get_include_path()
);
set_include_path(implode(PATH_SEPARATOR, $path));

/**
 * Register autoloader
 */
require_once 'Zend/Loader.php';
Zend_Loader::registerAutoload();

/**
 * Store application root in registry
 */
Zend_Registry::set('testRoot', $root);
Zend_Registry::set('testBootstrap', $root . '/application/bootstrap.php');

/*
 * Unset global variables that are no longer needed.
 */
unset($root, $library, $models, $controllers, $tests, $path);
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>The above ensures that my APPLICATION_ENV constant is set
appropriately, that error reporting is appropriate for tests (i.e.,
I want to see <xhtml:em>all</xhtml:em> errors), and that autoloading is
enabled. Additionally, I place a couple items in my registry -- the
bootstrap and test root directory.</xhtml:p>
<xhtml:p>In each test case file, I then do a require_once on this file.
In future versions of PHPUnit, you'll be able to specify a
bootstrap file in your configuration XML that gets pulled in for
each test case, and you'll be able to even further automate your
testing environment setup.</xhtml:p>
<xhtml:p>Hopefully this will get you started with your application
testing; what are you waiting for?</xhtml:p>
</xhtml:div>
    </content>
  </entry>
  <entry xmlns:xhtml="http://www.w3.org/1999/xhtml">
    <title type="html"><![CDATA[Migrating OOP Libraries and Frameworks to PHP 5.3]]></title>
    <published>2008-06-30T13:00:00+0000</published>
    <updated>2008-07-07T03:49:14+0000</updated>
    <link rel="alternate" type="text/html" href="http://mwop.net/blog/181-Migrating-OOP-Libraries-and-Frameworks-to-PHP-5.3.html"/>
    <id>http://mwop.net/blog/181-Migrating-OOP-Libraries-and-Frameworks-to-PHP-5.3.html</id>
    <author>
      <name>Matthew Weier O'Phinney</name>
      <email>me@mwop.net</email>
      <uri>http://mwop.net</uri>
    </author>
    <content xmlns:xhtml="http://www.w3.org/1999/xhtml" type="xhtml">
      <xhtml:div xmlns:xhtml="http://www.w3.org/1999/xhtml"><xhtml:p>With PHP 5.3 coming up on the horizon, I'm of course looking
forward to using namespaces. Let's be honest, who wants to write
the following line?</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="php" xml:lang="php">
$viewRenderer = Zend_Controller_Action_HelperBroker::getStaticHelper('viewRenderer');
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>when the more succinct:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="php" xml:lang="php">
$viewRenderer = HelperBroker::getStaticHelper('viewRenderer');
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>could be used? (Assuming you've executed <xhtml:code>'use
Zend::Controller::Action;'</xhtml:code> somewhere earlier...)</xhtml:p>
<xhtml:p>However, while namespaces will hopefully lead to more readable
code, particularly code in libraries and frameworks, PHP developers
will finally need to start thinking about sane standards for
abstract classes and interfaces.</xhtml:p>
<xhtml:p>For instance, we've been doing things like the following in Zend
Framework:</xhtml:p>
<xhtml:ul>
<xhtml:li>Zend_Controller_Request_Abstract</xhtml:li>
<xhtml:li>Zend_View_Interface</xhtml:li>
</xhtml:ul>
<xhtml:p>These conventions make it really easy to find Abstract classes
and Interfaces using <xhtml:code>find</xhtml:code> or <xhtml:code>grep</xhtml:code>, and
also are predictable and easy to understand. However, they won't
play well with namespaces. Why? Consider the following:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="php" xml:lang="php">
namespace Zend::Controller::Request

class Http extends Abstract
{
    // ...
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>Spot the problem? 'Abstract' is a reserved word in PHP. The same
goes for interfaces. Consider this particularly aggregious
example:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="php" xml:lang="php">
namespace Zend::View

abstract class Abstract implements Interface
{
    // ...
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>We've got two reserved words there: Abstract <xhtml:em>and</xhtml:em>
Interface.</xhtml:p>
<xhtml:p><xhtml:a href="http://php100.wordpress.com/">Stas</xhtml:a>, Dmitry, and I
sat down to discuss this a few weeks ago to come up with a plan for
migrating to PHP 5.3. In other OOP languages, such as Python, C#,
interfaces are denoted by prefixing the interface with a capital
'I'; in the example above, we would then have
<xhtml:code>Zend::View::IView</xhtml:code>. We decided this would be a sane
step, as it would keep the interface within the namespace, and
visually denote it as well. We also decided that this convention
made sense for abstract classes: <xhtml:code>Zend::View::AView</xhtml:code>.
So, our two examples become:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="php" xml:lang="php">
namespace Zend::Controller::Request

class Http extends ARequest
{
    // ...
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>and:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="php" xml:lang="php">
namespace Zend::View

abstract class AView implements IView
{
    // ...
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>Another thing that looks likely to affect OOP libraries and
frameworks is autoloading, specifically when using exceptions. For
instance, consider this:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="php" xml:lang="php">
namespace Foo::Bar

class Baz
{
    public function status()
    {
        throw new Exception(\"This isn't what you think it is\");
    }
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>You'd expect the exception to be of class
<xhtml:code>Foo::Bar::Exception</xhtml:code>, right? Wrong; it'll be a standard
<xhtml:code>Exception</xhtml:code>. To get around this, you can do the
following:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="php" xml:lang="php">
namespace Foo::Bar

class Baz
{
    public function status()
    {
        throw new namespace::Exception(\"This is exactly what you think it is\");
    }
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>By using the <xhtml:code>namespace</xhtml:code> keyword, you're telling the
PHP engine to explicitly use the Exception class from the current
namespace. I also find this to be more semantically correct -- it's
more explicit that you're throwing a particular type of exception,
and makes it easy to find and replace these with alternate
declarations at a later date.</xhtml:p>
<xhtml:p>I'd like to recommend other libraries adopt similar standards --
they're sensible, and fit already within PEAR/Horde/ZF coding
standards. What say you?</xhtml:p>
</xhtml:div>
    </content>
  </entry>
</feed>
