<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:slash="http://purl.org/rss/1.0/modules/slash/">
  <channel>
    <title>Tag: apigility :: phly, boy, phly</title>
    <description>Tag: apigility :: phly, boy, phly</description>
    <pubDate>Tue, 02 Sep 2014 13:30:00 +0000</pubDate>
    <generator>Zend_Feed_Writer 2 (http://framework.zend.com)</generator>
    <link>http://mwop.net/blog/tag/apigility.html</link>
    <atom:link rel="self" type="application/rss+xml" href="http://mwop.net/blog/tag/apigility-rss.xml"/>
    <item>
      <title>Deployment with Zend Server (Part 3 of 8)</title>
      <pubDate>Tue, 02 Sep 2014 13:30:00 +0000</pubDate>
      <link>http://mwop.net/blog/2014-09-02-zend-server-deployment-part-3.html</link>
      <guid>http://mwop.net/blog/2014-09-02-zend-server-deployment-part-3.html</guid>
      <author>me@mwop.net (Matthew Weier O'Phinney)</author>
      <dc:creator>Matthew Weier O'Phinney</dc:creator>
      <content:encoded><![CDATA[<p>
    This is the third in a series of eight posts detailing tips on deploying
    to Zend Server. <a href="/blog/2014-08-28-zend-server-deployment-part-2.html">The previous post in the series</a>
    detailed creating recurring jobs via Zend Job Queue, à la cronjobs.
</p>

<p>
    Today, I'm sharing a very short deployment script tip learned by experience.
</p><h2>Tip 3: chmod</h2>

<p>
    In the <a href="/blog/2014-08-11-zend-server-deployment-part-1.html">first tip</a>,
    I detailed writing deployment scripts. One of the snippets I shared was a <kbd>chmod</kbd>
    routine:
</p>

<div class="example"><pre><code language="php">
$command = 'chmod -R a+rwX ./data';
echo "\nExecuting `$command`\n";
system($command);
</code></pre></div>

<p>
    The code is fine; what I did not share is <em>where</em> in the deployment script
    you should invoke it. As I discovered from experience, this is key.
</p>

<p>
    Zend Server's deployment scripts run as the <kbd>zend</kbd> user. If they are 
    writing any data to the <kbd>data</kbd> directory, that data is owned by the <kbd>zend</kbd> 
    user and group -- and often will not be writable by the web server user.  If you 
    have scheduled jobs that need to write to the same files, they will fail... 
    unless you have done the <kbd>chmod</kbd> after your deployment tasks are done.
</p>

<p>
    So, that's today's tip: if you need any directory in your application to be
    writable by scheduled jobs, which will run as the web server user, make sure
    you do your <kbd>chmod</kbd> as the last step of your deployment script.
</p>

<h2>Next time...</h2>

<p>
    The next tip in the series is another short one, and will detail how to
    secure your Job Queue job scripts.
</p>

<h2>Other articles in the series</h2>

<ul>
    <li><a href="/blog/2014-08-11-zend-server-deployment-part-1.html">Tip 1: zf-deploy</a></li>
    <li><a href="/blog/2014-08-28-zend-server-deployment-part-2.html">Tip 2: Recurring Jobs</a></li>
</ul

<p>
    I will update this post to link to each article as it releases.
</p>]]></content:encoded>
      <slash:comments>0</slash:comments>
    </item>
    <item>
      <title>Deployment with Zend Server (Part 2 of 8)</title>
      <pubDate>Tue, 02 Sep 2014 13:30:00 +0000</pubDate>
      <link>http://mwop.net/blog/2014-08-28-zend-server-deployment-part-2.html</link>
      <guid>http://mwop.net/blog/2014-08-28-zend-server-deployment-part-2.html</guid>
      <author>me@mwop.net (Matthew Weier O'Phinney)</author>
      <dc:creator>Matthew Weier O'Phinney</dc:creator>
      <content:encoded><![CDATA[<p>
    This is the second in a series of eight posts detailing tips on deploying
    to Zend Server. <a href="/blog/2014-08-11-zend-server-deployment-part-1.html">The previous post in the series</a>
    detailed getting started with <a href="http://www.zend.com/en/solutions/cloud-solutions/aws-marketplace">Zend
    Server on the AWS marketplace</a> and using <a href="https://github.com/zfcampus/zf-deploy">zf-deploy</a>
    to create ZPK packages to deploy to Zend Server.
</p>

<p>
    Today, I'm looking at how to created scheduled/recurring jobs using Zend Server's Job Queue;
    think of this as application-level cronjobs.
</p><h2>Tip 2: Recurring Jobs</h2>

<p>
    I needed to define a few recurring jobs on the server. In the past, I've 
    used <kbd>cron</kbd> for this, but I've recently had a slight change of mind on 
    this: if I use <kbd>cron</kbd>, I have to assume I'm running on a unix-like system, 
    and have some sort of system access to the server. If I have multiple 
    servers running, that means ensuring they're setup on each server. It seems 
    better to be able to define these jobs at the applicaton level.
</p>

<p>
    Since Zend Server comes with Job Queue, I decided to try it out for 
    scheduling recurring jobs. This is not terribly intuitive, however. The UI 
    allows you to define scheduled jobs... but only gives options for every 
    minute, hour, day, week, and month, without allowing you to specify the 
    exact interval (e.g., every day at 20:00).

<p>
    The PHP API, however, makes this easy. I can create a job as follows:
</p>

<div class="example"><pre><code language="php">
$queue = new ZendJobQueue();
$queue->createHttpJob('/jobs/github-feed.php', [], [
  'name'       => 'github-feed',
  'persistent' => false,
  'schedule'   => '5,20,35,40 * * * *',
]);
</code></pre></div>

<p>
    Essentially, you provide a URL to the script to execute (Job Queue "runs" a 
    job by accessing a URL on the server), and provide a schedule in crontab 
    format. I like to give my jobs names as well, as it allows me to search for 
    them in the UI, and also enables linking between the rules and the logs in 
    the UI. Marking them as <em>not</em> persistent ensures that if the job is 
    successful, it will be removed from the events list.
</p>

<p>
    The question is, where do you define this? I decided to do this in my 
    <kbd>post_activate.php</kbd> deployment script. However, this raises two new 
    problems:
</p>

<ul>
    <li>Rules need not just a path to the script, but also the scheme and host. 
        You _can_ omit those, but only if the script can resolve them via 
        <kbd>$_SERVER</kbd>... which it cannot due during deployment.</li>
    <li>Each deployment adds the jobs you define... but this does not overwrite 
        or remove the jobs you added in previous deployments.</li>
</ul>

<p>
    I solved these as follows:
</p>

<div class="example"><pre><code language="php">
$server = 'http://mwop.net';

// Remove previously scheduled jobs:
$queue = new ZendJobQueue();
foreach ($queue->getSchedulingRules() as $job) {
    if (0 !== strpos($job['script'], $server)) {
        // not one we're interested in
        continue;
    }

    // Remove previously scheduled job
    $queue->deleteSchedulingRule($job['id']);
}

$queue->createHttpJob($server . '/jobs/github-feed.php', [], [
  'name'       => 'github-feed',
  'persistent' => false,
  'schedule'   => '5,20,35,40 * * * *',
]);
</code></pre></div>

<p>
    So, in summary:
</p>

<ul>
    <li>Define your rules with names.</li>
    <li>Define recurring rules using the <kbd>schedule</kbd> option.</li>
    <li>Define recurring rules in your deployment script, during <kbd>post_activate</kbd>.</li>
    <li>Remove previously defined rules in your deployment script, prior to defining them.</li>
</ul>

<h2>Next time...</h2>

<p>
    The next tip in the series is a short one, perfect for following the US 
    Labor Day weekend, and details something I learned the hard way from Tip 1 
    when setting up deployment tasks.
</p>

<h2>Other articles in the series</h2>

<ul>
    <li><a href="/blog/2014-08-11-zend-server-deployment-part-1.html">Tip 1: zf-deploy</a></li>
    <li><a href="/blog/2014-09-02-zend-server-deployment-part-3.html">Tip 3: chmod</a></li>
</ul

<p>
    I will update this post to link to each article as it releases.
</p>]]></content:encoded>
      <slash:comments>0</slash:comments>
    </item>
    <item>
      <title>Deployment with Zend Server (Part 1 of 8)</title>
      <pubDate>Tue, 02 Sep 2014 13:30:00 +0000</pubDate>
      <link>http://mwop.net/blog/2014-08-11-zend-server-deployment-part-1.html</link>
      <guid>http://mwop.net/blog/2014-08-11-zend-server-deployment-part-1.html</guid>
      <author>me@mwop.net (Matthew Weier O'Phinney)</author>
      <dc:creator>Matthew Weier O'Phinney</dc:creator>
      <content:encoded><![CDATA[<p>
    I manage a number of websites running on Zend Server, Zend's PHP 
    application platform. I've started accumulating a number of patterns and 
    tricks that make the deployments more successful, and which also allow 
    me to do more advanced things such as setting up recurring jobs for the 
    application, clearing page caches, and more.
</p><h2>Yes, YOU can afford Zend Server</h2>

<p>
    "But, wait, Zend Server is uber-expensive!" I hear some folks saying.
</p>

<p>
    Well, yes and no.
</p>

<p>
    With the release of Zend Server 7, Zend now offers a "Development 
    Edition" that contains all the features I've covered here, and which 
    runs $195. This makes it affordable for small shops and freelancers, 
    but potentially out of the reach of individuals.
</p>

<p>
    But there's another option, which I'm using, which is even more 
    intriguing: <a href="http://www.zend.com/en/solutions/cloud-solutions/aws-marketplace">Zend Server on the Amazon Web Services (AWS) Marketplace</a>. 
    On AWS, you can try out Zend Server free for 30 days. After that, 
    you get charged a fee on top of your normal AWS EC2 usage. Depending 
    on the EC2 instance you choose, this can run as low as ~$24/month 
    (this is on the t1.micro, and that's the total per month for both 
    AWS and Zend Server usage). That's cheaper than most VPS hosting or 
    PaaS providers, and gives you a full license for Zend Server.
</p>

<p>
    Considering Zend Server is available on almost every PaaS and IaaS 
    offering available, this is a great way to try it out, as well as to 
    setup staging and testing servers cheaply; you can then choose the
    provider you want based on its other features. For those of you running 
    low traffic or small, personal or hobbyist sites, it's an 
    inexpensive alternative to VPS hosting.
</p>

<p>
    So... onwards with my first tip.
</p>

<h2>Tip 1: zf-deploy</h2>

<p>
    My first trick is to use 
    <a href="https://github.com/zfcampus/zf-deploy">zf-deploy</a>. This is a tool 
    <a href="https://twitter.com/ezimuel">Enrico</a> and I wrote when prepping 
    <a href="https://apigility.org">Apigility</a> for its initial stable release. 
    It allows you to create deployment packages from your application, 
    including zip, tarball, and ZPKs (Zend Server deployment packages). 
    We designed it to simplify packaging <a href="http://framework.zend.com">Zend Framework 2</a> and Apigility applications, but with a 
    small amount of work, it could likely be used for a greater variety 
    of PHP applications.
</p>

<p>
    zf-deploy takes the current state of your working directory, and 
    clones it to a working path. It then runs Composer (though you can 
    disable this), and strips out anything configured in your 
    <kbd>.gitignore</kbd> file (again, you can disable this). From there, it 
    creates your package.
</p>

<p>
    One optional piece is that, when creating a ZPK, you can tell it 
    which <kbd>deployment.xml</kbd> you want to use and/or specify a directory 
    containing the <kbd>deployment.xml</kbd> and any install scripts you want to 
    include in the package. This latter is incredibly useful, as you can 
    use this to shape your deployment.
</p>

<p>
    As an example, on my own website, I have a CLI job that will fetch 
    my latest <a href="https://github.com">GitHub</a> activity. I can invoke that 
    in my <kbd>post_stage.php</kbd> script:
</p>

<div class="example"><pre><code language="php">
if (! chdir(getenv('ZS_APPLICATION_BASE_DIR'))) {
  throw new Exception('Unable to change to application directory');
}

$php = '/usr/local/zend/bin/php';

$command = $php . ' public/index.php githubfeed fetch';
echo "\nExecuting `$command`\n";
system($command);
</code></pre></div>

<p>
    One task I always do is make sure my application data directory is 
    writable by the web server. This next line builds on the above, in 
    that it assumes you've changed to your application directory first:
</p>

<div class="example"><pre><code language="php">
$command = 'chmod -R a+rwX ./data';
echo "\nExecuting `$command`\n";
system($command);
</code></pre></div>

<p>
    Yes, PHP has a built-in for <kbd>chmod</kbd>, but it doesn't act recursively.
</p>

<p>
    For ZF2 and Apigility applications, zf-deploy also allows you to 
    specify a directory that contains the <kbd>*local.php</kbd> config 
    scripts for your <kbd>config/autoload/</kbd> directory, allowing you to 
    merge in configuration specific for the deployment environment. 
    This is a fantastic capability, as I can keep any private 
    configuration separate from my main repository.
</p>

<p>
    Deployment now becomes:
</p>

<div class="example"><pre><code language="bash">
$ vendor/bin/zfdeploy.php mwop.net.zpk --configs=../mwop.net-config --zpk=zpk
</code></pre></div>

<p>
    and I now have a ZPK ready to push to Zend Server.
</p>

<p>
    In sum: zf-deploy simplifies ZPK creation, and allows you to add 
    deployment scripts that let you perform other tasks on the server.
</p>

<h2>Next time...</h2>

<p>
    I've got a total of 8 tips queued up, including this one, and will 
    be publishing on Tuesdays and Thursdays; I'll update each post
    to link to the others in the series. Next tip: creating scheduled
    Job Queue jobs, à la cronjobs.
</p>

<h2>Other articles in the series</h2>

<ul>
    <li><a href="/blog/2014-08-28-zend-server-deployment-part-2.html">Tip 2: Recurring Jobs</a></li>
    <li><a href="/blog/2014-09-02-zend-server-deployment-part-3.html">Tip 3: chmod</a></li>
</ul

<p>
    I will update this post to link to each article as it releases.
</p>]]></content:encoded>
      <slash:comments>0</slash:comments>
    </item>
    <item>
      <title>Apigility: Using RPC with HAL</title>
      <pubDate>Wed, 26 Mar 2014 20:30:00 +0000</pubDate>
      <link>http://mwop.net/blog/2014-03-26-apigility-rpc-with-hal.html</link>
      <guid>http://mwop.net/blog/2014-03-26-apigility-rpc-with-hal.html</guid>
      <author>me@mwop.net (Matthew Weier O'Phinney)</author>
      <dc:creator>Matthew Weier O'Phinney</dc:creator>
      <content:encoded><![CDATA[<p>
    A few days ago, we <a href="http://bit.ly/ag-1-beta1">released our first beta of Apigility</a>.
    We've started our documentation effort now, and one question has arisen a few times that I
    want to address: How can you use Hypermedia Application Language (HAL) in RPC services?
</p><h2>HAL?</h2>

<p>
    <a href="http://tools.ietf.org/html/draft-kelly-json-hal-06">Hypermedia Application Language</a>
    is an IETF proposal for how to represent resources and their relations within APIs. Technically,
    it provides two mediatypes, <code>application/hal+json</code> and <code>application/hal+xml</code>;
    however, Apigility only provides the JSON variant.
</p>

<p>
    The important things to know about HAL are:
</p>

<ul>
    <li>
        <p>
            It provides a standard way of describing relational links. All relational
            links are under a <code>_links</code> property of the resource. That property
            is an object. Each property of that object is a link relation; the value of
            each link relation is an object (or array of such objects) describing the link
            that must minimally contain an <code>href</code> proerty. The link object
            itself can contain some additional metadata, such as a mediatype, a name
            (useful for differentiating between multiple link objects assigned to the same
            relation).
        </p>

        <p>
            While not required, the specification recommends resources contain a "self"
            relational link, indicating the canonical location for the resource. This
            is particularly useful when we consider embedding (the next topic).
        </p>

        <p>
            Sound hard? It's not:
        </p>

        <div class="example"><pre><code language="javascript">
{
    "_links": {
        "self": {
            "href": "/blog/2014-03-26-apigility-rpc-with-hal"
        }
    }
}
        </code></pre></div>
    </li>

    <li>
        <p>
            Besides link relations, HAL also provides a standard way of describing
            <em>embedded resources</em>. An embedded resource is any other resource
            you can address via your API, and, as such, would be structured as a HAL
            resource -- in other words, it would have a <code>_links</code> property
            with relational links. Essentially, any property of the resource you're
            returning that can itself be addressed via the URI must be <em>embedded</em>
            in the resource. This is done via the property <code>_embedded</code>.
        </p>

        <p>
            Like <code>_links</code>, <code>_embedded</code> is an object. Each key in the
            object is the local name by which the resource refers to the embedded resource.
            The value of such keys can either be HAL resources or <em>arrays</em> of HAL
            resources; in fact, this is how <em>collections</em> are represented in HAL!
        </p>

        <p>
            As examples:
        </p>

        <div class="example"><pre><code language="javascript">
{
    "_links": {
        "self": {
            "href": "/blog/2014-03-26-apigility-rpc-with-hal"
        }
    },
    "_embedded": {
        "author": {
            "_links": {
                "self": {
                    "href": "/blog/author/matthew"
                }
            },
            "id": "matthew",
            "name": "Matthew Weier O'Phinney",
            "url": "http://mwop.net"
        },
        "tags": [
            {
                "_links": {
                    "self": {
                        "href": "/blog/tag/php"
                    }
                },
                "id": "php"
            },
            {
                "_links": {
                    "self": {
                        "href": "/blog/tag/rest"
                    }
                },
                "id": "rest"
            }
        ]
    }
}
        </code></pre></div>

        <p>
            The example above shows two embedded resources. The first is the author;
            the second, a collection of tags. Note that <em>every</em> object
            under <code>_embedded</code> is a HAL object!
        </p>

        <p>
            You can go quite far with this -- you can also have embedded resources
            inside your embedded resources, arbitrarily deep.
        </p>
    </li>
</ul>

<h2>RPC?</h2>

<p>
    RPC stands for Remote Procedure Call, and, when describing a web API, is 
    usually used to describe a web service that publishes multiple method calls 
    at a single URI using only <code>POST</code>; XML-RPC and SOAP are the
    usual suspects.
</p>

<p>
    In Apigility, we use the term RPC in a much looser sense; we use it to describe
    one-off services: actions like "authenticate," or "notify," or "register" 
    would all make sense here. They are actions that usually only need to respond
    to a single HTTP method, and which may or may not describe a "thing", which
    is what we usually consider a "resource" when discussing REST terminology.
</p>

<p>
    That said: what if what we want to return from the RPC call <em>are</em> REST
    resources?
</p>

<h2>Returning HAL from RPC Services</h2>

<p>
    In order to return HAL from RPC services, we need to understand (a) how 
    Content Negotiation works, and (b) what needs to be returned in order for the
    HAL renderer to be able to create a representation.
</p>

<p>
    For purposes of this example, I'm positing a <code>RegisterController</code> as
    an RPC service that, on success, is returning a <code>User</code> object 
    that I want rendered as a HAL resource.
</p>

<p>
    The <a href="https://github.com/zfcampus/zf-content-negotiation">zf-content-negotiation</a>
    module takes care of content negotiation for Apigility. It introspects the <code>Accept</code>
    header in order to determine if we can return a representation, and then, if it can, will
    cast any <code>ZF\ContentNegotiation\ViewModel</code> returned from a controller to the
    appropriate view model for the representation. From there, a renderer will pick up the view
    model and do what needs to be done.
</p>

<p>
    So, the first thing we have to do is return <code>ZF\ContentNegotiation\ViewModel</code>
    instances from our controller.
</p>

<div class="example"><pre><code language="php">
use Zend\Mvc\Controller\AbstractActionController;
use ZF\ContentNegotiation\ViewModel;

class RegisterController extends AbstractActionController
{
    public function registerAction()
    {
        /* ... do some work ... get a user ... */
        return new ViewModel(array('user' => $user));
    }
}
</code></pre></div>

<p>
    The <a href="https://github.com/zfcampus/zf-hal">zf-hal</a> module in Apigility
    creates the actual HAL representations. <code>zf-hal</code> looks for a "payload" variable in
    the view model, and expects that value to be either a <code>ZF\Hal\Entity</code>
    (single item) or <code>ZF\Hal\Collection</code>. When creating an <code>Entity</code>
    object, you need the object being represented, as well as the identifier. 
    So, let's update our return value.
</p>

<div class="example"><pre><code language="php">
use Zend\Mvc\Controller\AbstractActionController;
use ZF\ContentNegotiation\ViewModel;
use ZF\Hal\Entity;

class RegisterController extends AbstractActionController
{
    public function registerAction()
    {
        /* ... do some work
         * ... get a $user
         * ... assume we have also now have an $id
         */
        return new ViewModel(array('payload' => array(
            'user' => new Entity($user, $id),
        )));
    }
}
</code></pre></div>

<p>
    <code>zf-hal</code> contains what's called a "metadata map". This is a map of classes to
    information on how <code>zf-hal</code> should render them: what route to use, what additional
    relational links to inject, how to serialize the object, what field represents
    the identifier, etc.
</p>

<p>
    In most cases, you will have likely already defined a REST service for the
    resource you want to return from the RPC service, in which case you will
    be done. However, if you want, you can go in and manually configure
    the metadata map in your API module's <code>config/module.config.php</code>
    file:
</p>

<div class="example"><pre><code language="php">
return array(
    /* ... */
    'zf-hal' => array(
        'metadata_map' => array(
            'User' => array(
                'route_name' => 'api.rest.user',
                'entity_identifier_name' => 'username',
                'route_identifier_name' => 'user_id',
                'hydrator' => 'Zend\Stdlib\Hydrator\ObjectProperty',
            ),
        ),
    ),
);
</code></pre></div>

<p>
    Finally, we need to make sure that the service is configured to actually return
    HAL. We can do this in the admin if we want. Find the "Content Negotiation" section
    of the admin, and the "Content Negotiation Selector" item, and set that to "HalJson";
    don't forget to save! Alternately, you can do this manually in the API module's 
    <code>config/module.config.php</code> file, under the <code>zf-content-negotiation</code>
    section:
</p>

<div class="example"><pre><code language="php">
return array(
    /* ... */
    'zf-content-negotiation' => array(
        'controllers' => array(
            /* ... */
            'RegisterController' => 'HalJson',
        ),
        /* ... */
    ),
);
</code></pre></div>

<p>
    Once your changes are complete, when you make a successful request to the URI
    for your "register" RPC service, you'll receive a HAL response pointing to the
    canonical URI for the user resource created!
</p>]]></content:encoded>
      <slash:comments>0</slash:comments>
    </item>
  </channel>
</rss>
